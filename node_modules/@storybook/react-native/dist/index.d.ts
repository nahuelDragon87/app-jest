import * as _storybook_core_types from '@storybook/core/types';
import { StoryIndex, PreparedStory, NormalizedStoriesSpecifier, StorybookConfig as StorybookConfig$1 } from '@storybook/core/types';
import { ReactRenderer } from '@storybook/react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { Channel } from '@storybook/core/channels';
import { StoryContext } from '@storybook/csf';
import { PreviewWithSelection } from '@storybook/core/preview-api';
import { Theme } from '@storybook/react-native-theming';
export { Theme, darkTheme, theme } from '@storybook/react-native-theming';

interface Storage {
    getItem: (key: string) => Promise<string | null>;
    setItem: (key: string, value: string) => Promise<void>;
}
type StoryKind = string;
type StoryName = string;
type InitialSelection = `${StoryKind}--${StoryName}` | {
    /**
     * Kind is the default export name or the storiesOf("name") name
     */
    kind: StoryKind;
    /**
     * Name is the named export or the .add("name") name
     */
    name: StoryName;
};
type DeepPartial<T> = T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T;
type Params = {
    onDeviceUI?: boolean;
    enableWebsockets?: boolean;
    query?: string;
    host?: string;
    port?: number;
    secured?: boolean;
    initialSelection?: InitialSelection;
    shouldPersistSelection?: boolean;
    theme: DeepPartial<Theme>;
    storage?: Storage;
};
declare class View {
    _storyIndex: StoryIndex;
    _setStory: (story: StoryContext<ReactRenderer>) => void;
    _forceRerender: () => void;
    _ready: boolean;
    _preview: PreviewWithSelection<ReactRenderer>;
    _asyncStorageStoryId: string;
    _webUrl: string;
    _storage: Storage;
    _channel: Channel;
    _idToPrepared: Record<string, PreparedStory<ReactRenderer>>;
    constructor(preview: PreviewWithSelection<ReactRenderer>, channel: Channel);
    _getInitialStory: ({ initialSelection, shouldPersistSelection, }?: Partial<Params>) => Promise<{
        storySpecifier: string;
        viewMode: string;
    }>;
    _getServerChannel: (params?: Partial<Params>) => Channel;
    createPreparedStoryMapping: () => Promise<void>;
    getStorybookUI: (params?: Partial<Params>) => () => react_jsx_runtime.JSX.Element;
}

/** Configuration options that are needed at startup, only serialisable values are possible */
interface ReactNativeOptions {
    /**
     * Note that this is for future and play functions are not yet fully supported on native.
     */
    playFn?: boolean;
}
declare function prepareStories({ storyEntries, options, }: {
    storyEntries: Array<NormalizedStoriesSpecifier & {
        req: any;
    }>;
    options?: ReactNativeOptions;
}): {
    index: StoryIndex;
    importMap: Record<string, any>;
};
declare const getProjectAnnotations: (view: View, annotations: any[]) => () => Promise<_storybook_core_types.NormalizedProjectAnnotations<ReactRenderer>>;
declare function start({ annotations, storyEntries, options, }: {
    storyEntries: Array<NormalizedStoriesSpecifier & {
        req: any;
    }>;
    annotations: any[];
    options?: ReactNativeOptions;
}): View;
declare function updateView(viewInstance: View, annotations: any[], normalizedStories: Array<NormalizedStoriesSpecifier & {
    req: any;
}>, options?: ReactNativeOptions): void;

interface StorybookConfig {
    stories: StorybookConfig$1['stories'];
    addons: string[];
    reactNative?: ReactNativeOptions;
}

export { StorybookConfig, getProjectAnnotations, prepareStories, start, updateView };
