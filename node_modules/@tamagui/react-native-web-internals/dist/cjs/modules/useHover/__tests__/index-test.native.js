"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));
var import_jsx_runtime = require("react/jsx-runtime"), import_dom_event_testing_library = require("dom-event-testing-library"), React = __toESM(require("react")), ReactDOM = __toESM(require("react-dom")), import_test_utils = require("react-dom/test-utils"), import_modality = require("../../modality/index"), import__ = __toESM(require(".."));
function createRoot(rootNode) {
  return {
    render(element) {
      ReactDOM.render(element, rootNode);
    }
  };
}
(0, import_dom_event_testing_library.describeWithPointerEvent)("useHover", function(hasPointerEvents) {
  var root, rootNode;
  beforeEach(function() {
    (0, import_dom_event_testing_library.setPointerEvent)(hasPointerEvents), rootNode = document.createElement("div"), document.body.appendChild(rootNode), root = createRoot(rootNode);
  }), afterEach(function() {
    root.render(null), document.body.removeChild(rootNode), rootNode = null, root = null, (0, import_modality.testOnly_resetActiveModality)(), (0, import_dom_event_testing_library.clearPointers)();
  }), describe("contain", function() {
    var onHoverChange, onHoverStart, onHoverUpdate, onHoverEnd, ref, childRef, componentInit = function() {
      onHoverChange = jest.fn(), onHoverStart = jest.fn(), onHoverUpdate = jest.fn(), onHoverEnd = jest.fn(), ref = /* @__PURE__ */ React.createRef(), childRef = /* @__PURE__ */ React.createRef();
      var Component = function() {
        return (0, import__.default)(ref, {
          onHoverChange,
          onHoverStart,
          onHoverUpdate,
          onHoverEnd
        }), (0, import__.default)(childRef, {
          contain: !0
        }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
          ref,
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
            ref: childRef
          })
        });
      };
      (0, import_test_utils.act)(function() {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("contains the hover gesture", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current), child = (0, import_dom_event_testing_library.createEventTarget)(childRef.current);
      (0, import_test_utils.act)(function() {
        target.pointerover(), target.pointerout(), child.pointerover();
      }), expect(onHoverEnd).toBeCalled(), (0, import_test_utils.act)(function() {
        child.pointerout();
      }), expect(onHoverStart).toBeCalled();
    });
  }), describe("disabled", function() {
    var onHoverChange, onHoverStart, onHoverUpdate, onHoverEnd, ref, componentInit = function() {
      onHoverChange = jest.fn(), onHoverStart = jest.fn(), onHoverUpdate = jest.fn(), onHoverEnd = jest.fn(), ref = /* @__PURE__ */ React.createRef();
      var Component = function() {
        return (0, import__.default)(ref, {
          disabled: !0,
          onHoverChange,
          onHoverStart,
          onHoverUpdate,
          onHoverEnd
        }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
          ref
        });
      };
      (0, import_test_utils.act)(function() {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("does not call callbacks", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerover(), target.pointerout();
      }), expect(onHoverChange).not.toBeCalled(), expect(onHoverStart).not.toBeCalled(), expect(onHoverUpdate).not.toBeCalled(), expect(onHoverEnd).not.toBeCalled();
    });
  }), describe("onHoverStart", function() {
    var onHoverStart, ref, componentInit = function() {
      onHoverStart = jest.fn(), ref = /* @__PURE__ */ React.createRef();
      var Component = function() {
        return (0, import__.default)(ref, {
          onHoverStart
        }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
          ref
        });
      };
      (0, import_test_utils.act)(function() {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("is called for mouse pointers", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerover({
          pointerType: "mouse"
        });
      }), expect(onHoverStart).toBeCalledTimes(1);
    }), test("is not called for touch pointers", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerdown({
          pointerType: "touch"
        }), target.pointerup({
          pointerType: "touch"
        });
      }), expect(onHoverStart).not.toBeCalled();
    }), test("is called if a mouse pointer is used after a touch pointer", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerdown({
          pointerType: "touch"
        }), target.pointerup({
          pointerType: "touch"
        }), target.pointerover({
          pointerType: "mouse"
        });
      }), expect(onHoverStart).toBeCalledTimes(1);
    });
  }), describe("onHoverChange", function() {
    var onHoverChange, ref, componentInit = function() {
      onHoverChange = jest.fn(), ref = /* @__PURE__ */ React.createRef();
      var Component = function() {
        return (0, import__.default)(ref, {
          onHoverChange
        }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
          ref
        });
      };
      (0, import_test_utils.act)(function() {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("is called for mouse pointers", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerover();
      }), expect(onHoverChange).toBeCalledTimes(1), expect(onHoverChange).toBeCalledWith(!0), (0, import_test_utils.act)(function() {
        target.pointerout();
      }), expect(onHoverChange).toBeCalledTimes(2), expect(onHoverChange).toBeCalledWith(!1);
    }), test("is not called for touch pointers", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerdown({
          pointerType: "touch"
        }), target.pointerup({
          pointerType: "touch"
        });
      }), expect(onHoverChange).not.toBeCalled();
    });
  }), describe("onHoverEnd", function() {
    var onHoverEnd, ref, childRef, componentInit = function() {
      onHoverEnd = jest.fn(), ref = /* @__PURE__ */ React.createRef(), childRef = /* @__PURE__ */ React.createRef();
      var Component = function() {
        return (0, import__.default)(ref, {
          onHoverEnd
        }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
          ref,
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
            ref: childRef
          })
        });
      };
      (0, import_test_utils.act)(function() {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("is called for mouse pointers", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerover(), target.pointerout();
      }), expect(onHoverEnd).toBeCalledTimes(1);
    }), test("is not called for touch pointers", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerdown({
          pointerType: "touch"
        }), target.pointerup({
          pointerType: "touch"
        });
      }), expect(onHoverEnd).not.toBeCalled();
    }), test("is not called when entering children of the target", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current), child = (0, import_dom_event_testing_library.createEventTarget)(childRef.current);
      (0, import_test_utils.act)(function() {
        target.pointerover(), target.pointerout({
          relatedTarget: childRef.current
        }), child.pointerover({
          relatedTarget: target.node
        });
      }), expect(onHoverEnd).not.toBeCalled();
    });
  }), describe("onHoverUpdate", function() {
    test('is called after the active pointer moves"', function() {
      var onHoverUpdate = jest.fn(), ref = /* @__PURE__ */ React.createRef(), Component = function() {
        return (0, import__.default)(ref, {
          onHoverUpdate
        }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
          ref
        });
      };
      (0, import_test_utils.act)(function() {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerover(), target.pointerhover({
          x: 0,
          y: 0
        }), target.pointerhover({
          x: 1,
          y: 1
        });
      }), expect(onHoverUpdate).toBeCalledTimes(2);
    });
  }), describe("repeat use", function() {
    var onHoverChange, onHoverStart, onHoverUpdate, onHoverEnd, ref, componentInit = function() {
      onHoverChange = jest.fn(), onHoverStart = jest.fn(), onHoverUpdate = jest.fn(), onHoverEnd = jest.fn(), ref = /* @__PURE__ */ React.createRef();
      var Component = function() {
        return (0, import__.default)(ref, {
          onHoverChange,
          onHoverStart,
          onHoverUpdate,
          onHoverEnd
        }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
          ref
        });
      };
      (0, import_test_utils.act)(function() {
        root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {}));
      });
    };
    test("callbacks are called each time", function() {
      componentInit();
      var target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
      (0, import_test_utils.act)(function() {
        target.pointerover(), target.pointerhover({
          x: 1,
          y: 1
        }), target.pointerout();
      }), expect(onHoverStart).toBeCalledTimes(1), expect(onHoverUpdate).toBeCalledTimes(1), expect(onHoverEnd).toBeCalledTimes(1), expect(onHoverChange).toBeCalledTimes(2), (0, import_test_utils.act)(function() {
        target.pointerover(), target.pointerhover({
          x: 1,
          y: 1
        }), target.pointerout();
      }), expect(onHoverStart).toBeCalledTimes(2), expect(onHoverUpdate).toBeCalledTimes(2), expect(onHoverEnd).toBeCalledTimes(2), expect(onHoverChange).toBeCalledTimes(4);
    });
  });
});
//# sourceMappingURL=index-test.js.map
