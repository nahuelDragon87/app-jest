import UIManager from "..";
var createStyledNode = function() {
  var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "div", style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, root = document.createElement(name);
  return Object.keys(style).forEach(function(prop) {
    root.style[prop] = style[prop];
  }), root;
}, componentStub = {
  _reactInternalInstance: {
    _currentElement: {
      _owner: {}
    },
    _debugID: 1
  }
};
describe("apis/UIManager", function() {
  describe("focus", function() {
    test('sets tabIndex="-1" on elements not programmatically focusable by default', function() {
      var node = createStyledNode();
      UIManager.focus(node), expect(node.getAttribute("tabIndex")).toEqual("-1");
    }), test(`doesn't set tabIndex="-1" on elements with an existing tabIndex`, function() {
      var node = createStyledNode();
      node.tabIndex = 0, UIManager.focus(node), expect(node.getAttribute("tabIndex")).toEqual("0");
    }), test(`doesn't set tabIndex="-1" on elements focusable by default`, function() {
      [
        "a",
        "input",
        "select",
        "textarea"
      ].forEach(function(name) {
        var node = createStyledNode(name);
        UIManager.focus(node), expect(node.getAttribute("tabIndex")).toBeNull();
      });
    });
  }), describe("updateView", function() {
    test("supports className alias for class", function() {
      var node = createStyledNode(), props = {
        className: "extra"
      };
      UIManager.updateView(node, props, componentStub), expect(node.getAttribute("class")).toEqual("extra");
    }), test("adds correct DOM styles to existing style", function() {
      var node = createStyledNode("div", {
        color: "red"
      }), props = {
        style: {
          marginTop: 0,
          marginBottom: 0,
          opacity: 0
        }
      };
      UIManager.updateView(node, props, componentStub), expect(node.getAttribute("style")).toEqual("color: red; margin-top: 0px; margin-bottom: 0px; opacity: 0;");
    }), test("replaces input and textarea text", function() {
      var node = createStyledNode("textarea");
      node.value = "initial";
      var textProp = {
        text: "expected-text"
      }, valueProp = {
        value: "expected-value"
      };
      UIManager.updateView(node, textProp), expect(node.value).toEqual("expected-text"), UIManager.updateView(node, valueProp), expect(node.value).toEqual("expected-value");
    }), test("sets other attribute values", function() {
      var node = createStyledNode(), props = {
        "aria-level": "4",
        "data-of-type": "string"
      };
      UIManager.updateView(node, props), expect(node.getAttribute("aria-level")).toEqual("4"), expect(node.getAttribute("data-of-type")).toEqual("string");
    });
  });
});
//# sourceMappingURL=index-test.js.map
