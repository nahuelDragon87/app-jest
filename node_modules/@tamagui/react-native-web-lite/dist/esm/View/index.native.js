import { forwardPropsListView, getLocaleDirection, pick, TextAncestorContext, useElementLayout, useLocaleContext, useMergeRefs, usePlatformMethods, useResponderEvents } from "@tamagui/react-native-web-internals";
import * as React from "react";
import createElement from "../createElement/index";
var pickProps = function(props) {
  return pick(props, forwardPropsListView);
}, View = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var { hrefAttrs, onLayout, onMoveShouldSetResponder, onMoveShouldSetResponderCapture, onResponderEnd, onResponderGrant, onResponderMove, onResponderReject, onResponderRelease, onResponderStart, onResponderTerminate, onResponderTerminationRequest, onScrollShouldSetResponder, onScrollShouldSetResponderCapture, onSelectionChangeShouldSetResponder, onSelectionChangeShouldSetResponderCapture, onStartShouldSetResponder, onStartShouldSetResponderCapture, ...rest } = props;
  process.env.NODE_ENV !== "production" && React.Children.toArray(props.children).forEach(function(item) {
    typeof item == "string" && console.error(`Unexpected text node: ${item}. A text node cannot be a child of a <View>.`);
  });
  var hasTextAncestor = React.useContext(TextAncestorContext), hostRef = React.useRef(null), { direction: contextDirection } = useLocaleContext();
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  var component = "div", langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, writingDirection = componentDirection || contextDirection, supportedProps = pickProps(rest);
  if (supportedProps.dir = componentDirection, supportedProps.style = [
    styles.view,
    hasTextAncestor && styles.inline,
    props.style
  ], props.href != null && (component = "a", hrefAttrs != null)) {
    var { download, rel, target } = hrefAttrs;
    download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
  }
  var platformMethodsRef = usePlatformMethods(supportedProps), setRef = useMergeRefs(hostRef, platformMethodsRef, forwardedRef);
  return supportedProps.ref = setRef, createElement(component, supportedProps, {
    writingDirection
  });
});
View.displayName = "View";
var styles = {
  view: {
    alignItems: "stretch",
    boxSizing: "border-box",
    display: "flex",
    flexBasis: "auto",
    flexDirection: "column",
    flexShrink: 0
  },
  inline: {
    display: "inline-flex"
  }
}, View_default = View;
export {
  View_default as default
};
//# sourceMappingURL=index.js.map
