import { invariant } from "@tamagui/react-native-web-internals";
import EmitterSubscription from "./_EmitterSubscription";
import EventSubscriptionVendor from "./_EventSubscriptionVendor";
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
}
var sparseFilterPredicate = function() {
  return !0;
}, EventEmitter = /* @__PURE__ */ function() {
  "use strict";
  function EventEmitter2() {
    var subscriber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new EventSubscriptionVendor();
    _class_call_check(this, EventEmitter2), this._subscriber = subscriber;
  }
  return _create_class(EventEmitter2, [
    {
      /**
      * Adds a listener to be invoked when events of the specified type are
      * emitted. An optional calling context may be provided. The data arguments
      * emitted will be passed to the listener function.
      *
      * TODO: Annotate the listener arg's type. This is tricky because listeners
      *       can be invoked with varargs.
      *
      * @param {string} eventType - Name of the event to listen to
      * @param {function} listener - Function to invoke when the specified event is
      *   emitted
      * @param {*} context - Optional context object to use when invoking the
      *   listener
      */
      key: "addListener",
      value: function(eventType, listener, context) {
        return this._subscriber.addSubscription(eventType, new EmitterSubscription(this, this._subscriber, listener, context));
      }
    },
    {
      /**
      * Removes all of the registered listeners, including those registered as
      * listener maps.
      *
      * @param {?string} eventType - Optional name of the event whose registered
      *   listeners to remove
      */
      key: "removeAllListeners",
      value: function(eventType) {
        this._subscriber.removeAllSubscriptions(eventType);
      }
    },
    {
      /**
      * @deprecated Use `remove` on the EventSubscription from `addListener`.
      */
      key: "removeSubscription",
      value: function(subscription) {
        invariant(subscription.emitter === this, "Subscription does not belong to this emitter."), this._subscriber.removeSubscription(subscription);
      }
    },
    {
      /**
      * Returns the number of listeners that are currently registered for the given
      * event.
      *
      * @param {string} eventType - Name of the event to query
      * @returns {number}
      */
      key: "listenerCount",
      value: function(eventType) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
        return subscriptions ? (
          // We filter out missing entries because the array is sparse.
          // "callbackfn is called only for elements of the array which actually
          // exist; it is not called for missing elements of the array."
          // https://www.ecma-international.org/ecma-262/9.0/index.html#sec-array.prototype.filter
          subscriptions.filter(sparseFilterPredicate).length
        ) : 0;
      }
    },
    {
      /**
      * Emits an event of the given type with the given data. All handlers of that
      * particular type will be notified.
      *
      * @param {string} eventType - Name of the event to emit
      * @param {...*} Arbitrary arguments to be passed to each registered listener
      *
      * @example
      *   emitter.addListener('someEvent', function(message) {
      *     console.log(message);
      *   });
      *
      *   emitter.emit('someEvent', 'abc'); // logs 'abc'
      */
      key: "emit",
      value: function(eventType) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
        if (subscriptions) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          for (var i = 0, l = subscriptions.length; i < l; i++) {
            var subscription = subscriptions[i];
            subscription && subscription.listener && subscription.listener.apply(subscription.context, args);
          }
        }
      }
    },
    {
      /**
      * @deprecated Use `remove` on the EventSubscription from `addListener`.
      */
      key: "removeListener",
      value: function(eventType, listener) {
        console.error("EventEmitter.removeListener('" + eventType + "', ...): Method has been deprecated. Please instead use `remove()` on the subscription returned by `EventEmitter.addListener`.");
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
        if (subscriptions)
          for (var i = 0, l = subscriptions.length; i < l; i++) {
            var subscription = subscriptions[i];
            subscription && subscription.listener === listener && subscription.remove();
          }
      }
    }
  ]), EventEmitter2;
}(), EventEmitter_default = EventEmitter;
export {
  EventEmitter_default as default
};
//# sourceMappingURL=_EventEmitter.js.map
