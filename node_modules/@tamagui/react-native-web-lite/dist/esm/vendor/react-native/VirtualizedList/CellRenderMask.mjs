import { invariant } from "@tamagui/react-native-web-internals";
class CellRenderMask {
  _numCells;
  _regions;
  constructor(numCells) {
    invariant(numCells >= 0, "CellRenderMask must contain a non-negative number of cells"), this._numCells = numCells, numCells === 0 ? this._regions = [] : this._regions = [{
      first: 0,
      last: numCells - 1,
      isSpacer: !0
    }];
  }
  enumerateRegions() {
    return this._regions;
  }
  addCells(cells) {
    if (invariant(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, "CellRenderMask.addCells called with invalid cell range"), cells.last < cells.first) return;
    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first),
      [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);
    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) return;
    const newLeadRegion = [],
      newTailRegion = [],
      newMainRegion = {
        ...cells,
        isSpacer: !1
      };
    firstIntersect.first < newMainRegion.first && (firstIntersect.isSpacer ? newLeadRegion.push({
      first: firstIntersect.first,
      last: newMainRegion.first - 1,
      isSpacer: !0
    }) : newMainRegion.first = firstIntersect.first), lastIntersect.last > newMainRegion.last && (lastIntersect.isSpacer ? newTailRegion.push({
      first: newMainRegion.last + 1,
      last: lastIntersect.last,
      isSpacer: !0
    }) : newMainRegion.last = lastIntersect.last);
    const replacementRegions = [...newLeadRegion, newMainRegion, ...newTailRegion],
      numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;
    this._regions.splice(firstIntersectIdx, numRegionsToDelete, ...replacementRegions);
  }
  numCells() {
    return this._numCells;
  }
  equals(other) {
    return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every((region, i) => region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer);
  }
  _findRegion(cellIdx) {
    let firstIdx = 0,
      lastIdx = this._regions.length - 1;
    for (; firstIdx <= lastIdx;) {
      const middleIdx = Math.floor((firstIdx + lastIdx) / 2),
        middleRegion = this._regions[middleIdx];
      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) return [middleRegion, middleIdx];
      cellIdx < middleRegion.first ? lastIdx = middleIdx - 1 : cellIdx > middleRegion.last && (firstIdx = middleIdx + 1);
    }
    invariant(!1, `A region was not found containing cellIdx ${cellIdx}`);
  }
}
export { CellRenderMask };
//# sourceMappingURL=CellRenderMask.mjs.map
