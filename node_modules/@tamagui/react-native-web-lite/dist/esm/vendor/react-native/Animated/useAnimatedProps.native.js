import _createForOfIteratorHelperLoose from "@babel/runtime/helpers/createForOfIteratorHelperLoose";
import { useLayoutEffect as _, startTransition, useCallback, useEffect, useMemo, useReducer, useRef } from "react";
import useRefEffect from "../useRefEffect";
import { AnimatedEvent } from "./AnimatedEvent";
import NativeAnimatedHelper from "./NativeAnimatedHelper";
import AnimatedProps from "./nodes/AnimatedProps";
var useLayoutEffect = typeof window > "u" ? useEffect : _;
function useAnimatedProps(props) {
  var _useReducer = useReducer(function(count) {
    return count + 1;
  }, 0), scheduleUpdate = _useReducer[1], onUpdateRef = useRef(null), node = useMemo(function() {
    return new AnimatedProps(props, function() {
      return onUpdateRef.current == null ? void 0 : onUpdateRef.current();
    });
  }, [
    props
  ]);
  useAnimatedPropsLifecycle(node);
  var refEffect = useCallback(function(instance) {
    node.setNativeView(instance), onUpdateRef.current = function() {
      startTransition(function() {
        scheduleUpdate();
      });
    };
    var target = getEventTarget(instance), events = [];
    for (var propName in props) {
      var propValue = props[propName];
      propValue instanceof AnimatedEvent && propValue.__isNative && (propValue.__attach(target, propName), events.push([
        propName,
        propValue
      ]));
    }
    return function() {
      onUpdateRef.current = null;
      for (var _iterator = _createForOfIteratorHelperLoose(events), _step; !(_step = _iterator()).done; ) {
        var _step$value = _step.value, _propName = _step$value[0], _propValue = _step$value[1];
        _propValue.__detach(target, _propName);
      }
    };
  }, [
    props,
    node
  ]), callbackRef = useRefEffect(refEffect);
  return [
    reduceAnimatedProps(node),
    callbackRef
  ];
}
function reduceAnimatedProps(node) {
  return {
    ...node.__getValue(),
    collapsable: !1
  };
}
function useAnimatedPropsLifecycle(node) {
  var prevNodeRef = useRef(null), isUnmountingRef = useRef(!1);
  useEffect(function() {
    NativeAnimatedHelper.API.flushQueue();
  }), useLayoutEffect(function() {
    return isUnmountingRef.current = !1, function() {
      isUnmountingRef.current = !0;
    };
  }, []), useLayoutEffect(function() {
    if (node.__attach(), prevNodeRef.current != null) {
      var prevNode = prevNodeRef.current;
      prevNode.__restoreDefaultValues(), prevNode.__detach(), prevNodeRef.current = null;
    }
    return function() {
      isUnmountingRef.current ? node.__detach() : prevNodeRef.current = node;
    };
  }, [
    node
  ]);
}
function getEventTarget(instance) {
  return typeof instance == "object" && typeof instance?.getScrollableNode == "function" ? (
    // $FlowFixMe[incompatible-use] - Legacy instance assumptions.
    instance.getScrollableNode()
  ) : instance;
}
export {
  useAnimatedProps as default
};
//# sourceMappingURL=useAnimatedProps.js.map
