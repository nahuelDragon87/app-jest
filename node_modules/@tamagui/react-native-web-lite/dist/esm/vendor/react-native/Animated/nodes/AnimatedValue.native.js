import { InteractionManager } from "@tamagui/react-native-web-internals";
import NativeAnimatedHelper from "../NativeAnimatedHelper";
import AnimatedInterpolation from "./AnimatedInterpolation";
import AnimatedWithChildren from "./AnimatedWithChildren";
function _assert_this_initialized(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function _call_super(_this, derived, args) {
  return derived = _get_prototype_of(derived), _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
}
function _get(target, property, receiver) {
  return typeof Reflect < "u" && Reflect.get ? _get = Reflect.get : _get = function(target2, property2, receiver2) {
    var base = _super_prop_base(target2, property2);
    if (base) {
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
    }
  }, _get(target, property, receiver || target);
}
function _get_prototype_of(o) {
  return _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of(subClass, superClass);
}
function _possible_constructor_return(self, call) {
  return call && (_type_of(call) === "object" || typeof call == "function") ? call : _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
  return _set_prototype_of = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of(o, p);
}
function _super_prop_base(object, property) {
  for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of(object), object !== null); )
    ;
  return object;
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct() {
  try {
    var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_is_native_reflect_construct = function() {
    return !!result;
  })();
}
var NativeAnimatedAPI = NativeAnimatedHelper.API;
function _flush(rootNode) {
  var animatedStyles = /* @__PURE__ */ new Set();
  function findAnimatedStyles(node) {
    typeof node.update == "function" ? animatedStyles.add(node) : node.__getChildren().forEach(findAnimatedStyles);
  }
  findAnimatedStyles(rootNode), animatedStyles.forEach(function(animatedStyle) {
    return animatedStyle.update();
  });
}
function _executeAsAnimatedBatch(id, operation) {
  NativeAnimatedAPI.setWaitingForIdentifier(id), operation(), NativeAnimatedAPI.unsetWaitingForIdentifier(id);
}
var AnimatedValue = /* @__PURE__ */ function(AnimatedWithChildren2) {
  _inherits(AnimatedValue2, AnimatedWithChildren2);
  function AnimatedValue2(value, config) {
    _class_call_check(this, AnimatedValue2);
    var _this;
    if (_this = _call_super(this, AnimatedValue2), typeof value != "number")
      throw new Error("AnimatedValue: Attempting to set value to undefined");
    return _this._startingValue = _this._value = value, _this._offset = 0, _this._animation = null, config && config.useNativeDriver && _this.__makeNative(), _this;
  }
  return _create_class(AnimatedValue2, [
    {
      key: "__detach",
      value: function() {
        var _this = this;
        this.__isNative && NativeAnimatedAPI.getValue(this.__getNativeTag(), function(value) {
          _this._value = value - _this._offset;
        }), this.stopAnimation(), _get(_get_prototype_of(AnimatedValue2.prototype), "__detach", this).call(this);
      }
    },
    {
      key: "__getValue",
      value: function() {
        return this._value + this._offset;
      }
    },
    {
      /**
      * Directly set the value.  This will stop any animations running on the value
      * and update all the bound properties.
      *
      * See https://reactnative.dev/docs/animatedvalue#setvalue
      */
      key: "setValue",
      value: function(value) {
        var _this = this;
        this._animation && (this._animation.stop(), this._animation = null), this._updateValue(value, !this.__isNative), this.__isNative && _executeAsAnimatedBatch(this.__getNativeTag().toString(), function() {
          return NativeAnimatedAPI.setAnimatedNodeValue(_this.__getNativeTag(), value);
        });
      }
    },
    {
      /**
      * Sets an offset that is applied on top of whatever value is set, whether via
      * `setValue`, an animation, or `Animated.event`.  Useful for compensating
      * things like the start of a pan gesture.
      *
      * See https://reactnative.dev/docs/animatedvalue#setoffset
      */
      key: "setOffset",
      value: function(offset) {
        this._offset = offset, this.__isNative && NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset);
      }
    },
    {
      /**
      * Merges the offset value into the base value and resets the offset to zero.
      * The final output of the value is unchanged.
      *
      * See https://reactnative.dev/docs/animatedvalue#flattenoffset
      */
      key: "flattenOffset",
      value: function() {
        this._value += this._offset, this._offset = 0, this.__isNative && NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
      }
    },
    {
      /**
      * Sets the offset value to the base value, and resets the base value to zero.
      * The final output of the value is unchanged.
      *
      * See https://reactnative.dev/docs/animatedvalue#extractoffset
      */
      key: "extractOffset",
      value: function() {
        this._offset += this._value, this._value = 0, this.__isNative && NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
      }
    },
    {
      /**
      * Stops any running animation or tracking. `callback` is invoked with the
      * final value after stopping the animation, which is useful for updating
      * state to match the animation position with layout.
      *
      * See https://reactnative.dev/docs/animatedvalue#stopanimation
      */
      key: "stopAnimation",
      value: function(callback) {
        this.stopTracking(), this._animation && this._animation.stop(), this._animation = null, callback && (this.__isNative ? NativeAnimatedAPI.getValue(this.__getNativeTag(), callback) : callback(this.__getValue()));
      }
    },
    {
      /**
      * Stops any animation and resets the value to its original.
      *
      * See https://reactnative.dev/docs/animatedvalue#resetanimation
      */
      key: "resetAnimation",
      value: function(callback) {
        this.stopAnimation(callback), this._value = this._startingValue, this.__isNative && NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), this._startingValue);
      }
    },
    {
      key: "__onAnimatedValueUpdateReceived",
      value: function(value) {
        this._updateValue(value, !1);
      }
    },
    {
      /*flush*/
      /**
      * Interpolates the value before updating the property, e.g. mapping 0-1 to
      * 0-10.
      */
      key: "interpolate",
      value: function(config) {
        return new AnimatedInterpolation(this, config);
      }
    },
    {
      /**
      * Typically only used internally, but could be used by a custom Animation
      * class.
      *
      * See https://reactnative.dev/docs/animatedvalue#animate
      */
      key: "animate",
      value: function(animation, callback) {
        var _this = this, handle = null;
        animation.__isInteraction && (handle = InteractionManager.createInteractionHandle());
        var previousAnimation = this._animation;
        this._animation && this._animation.stop(), this._animation = animation, animation.start(
          this._value,
          function(value) {
            _this._updateValue(value, !0);
          },
          /* flush */
          function(result) {
            _this._animation = null, handle !== null && InteractionManager.clearInteractionHandle(handle), callback && callback(result);
          },
          previousAnimation,
          this
        );
      }
    },
    {
      /**
      * Typically only used internally.
      */
      key: "stopTracking",
      value: function() {
        this._tracking && this._tracking.__detach(), this._tracking = null;
      }
    },
    {
      /**
      * Typically only used internally.
      */
      key: "track",
      value: function(tracking) {
        this.stopTracking(), this._tracking = tracking, this._tracking && this._tracking.update();
      }
    },
    {
      key: "_updateValue",
      value: function(value, flush) {
        if (value === void 0)
          throw new Error("AnimatedValue: Attempting to set value to undefined");
        this._value = value, flush && _flush(this), _get(_get_prototype_of(AnimatedValue2.prototype), "__callListeners", this).call(this, this.__getValue());
      }
    },
    {
      key: "__getNativeConfig",
      value: function() {
        return {
          type: "value",
          value: this._value,
          offset: this._offset
        };
      }
    }
  ]), AnimatedValue2;
}(AnimatedWithChildren), AnimatedValue_default = AnimatedValue;
export {
  AnimatedValue_default as default
};
//# sourceMappingURL=AnimatedValue.js.map
