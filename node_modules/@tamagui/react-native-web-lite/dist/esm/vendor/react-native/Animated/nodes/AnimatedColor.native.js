import normalizeColor from "@tamagui/normalize-css-color";
import NativeAnimatedHelper from "../NativeAnimatedHelper";
import AnimatedValue from "./AnimatedValue";
import AnimatedWithChildren from "./AnimatedWithChildren";
function _assert_this_initialized(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function _call_super(_this, derived, args) {
  return derived = _get_prototype_of(derived), _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
}
function _get(target, property, receiver) {
  return typeof Reflect < "u" && Reflect.get ? _get = Reflect.get : _get = function(target2, property2, receiver2) {
    var base = _super_prop_base(target2, property2);
    if (base) {
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      return desc.get ? desc.get.call(receiver2 || target2) : desc.value;
    }
  }, _get(target, property, receiver || target);
}
function _get_prototype_of(o) {
  return _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), superClass && _set_prototype_of(subClass, superClass);
}
function _possible_constructor_return(self, call) {
  return call && (_type_of(call) === "object" || typeof call == "function") ? call : _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
  return _set_prototype_of = Object.setPrototypeOf || function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _set_prototype_of(o, p);
}
function _super_prop_base(object, property) {
  for (; !Object.prototype.hasOwnProperty.call(object, property) && (object = _get_prototype_of(object), object !== null); )
    ;
  return object;
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct() {
  try {
    var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_is_native_reflect_construct = function() {
    return !!result;
  })();
}
var NativeAnimatedAPI = NativeAnimatedHelper.API, defaultColor = {
  r: 0,
  g: 0,
  b: 0,
  a: 1
}, _uniqueId = 1, processColorObject = function(color) {
  return color;
};
function processColor(color) {
  if (color == null)
    return null;
  if (isRgbaValue(color))
    return color;
  var normalizedColor = normalizeColor(
    // $FlowIgnore[incompatible-cast] - Type is verified above
    color
  );
  if (normalizedColor == null)
    return null;
  if (typeof normalizedColor == "object") {
    var processedColorObj = processColorObject(normalizedColor);
    if (processedColorObj != null)
      return processedColorObj;
  } else if (typeof normalizedColor == "number") {
    var r = (normalizedColor & 4278190080) >>> 24, g = (normalizedColor & 16711680) >>> 16, b = (normalizedColor & 65280) >>> 8, a = (normalizedColor & 255) / 255;
    return {
      r,
      g,
      b,
      a
    };
  }
  return null;
}
function isRgbaValue(value) {
  return value && typeof value.r == "number" && typeof value.g == "number" && typeof value.b == "number" && typeof value.a == "number";
}
function isRgbaAnimatedValue(value) {
  return value && value.r instanceof AnimatedValue && value.g instanceof AnimatedValue && value.b instanceof AnimatedValue && value.a instanceof AnimatedValue;
}
var AnimatedColor = /* @__PURE__ */ function(AnimatedWithChildren2) {
  _inherits(AnimatedColor2, AnimatedWithChildren2);
  function AnimatedColor2(valueIn, config) {
    _class_call_check(this, AnimatedColor2);
    var _this;
    _this = _call_super(this, AnimatedColor2), _this._listeners = {};
    var value = valueIn ?? defaultColor;
    if (isRgbaAnimatedValue(value)) {
      var rgbaAnimatedValue = value;
      _this.r = rgbaAnimatedValue.r, _this.g = rgbaAnimatedValue.g, _this.b = rgbaAnimatedValue.b, _this.a = rgbaAnimatedValue.a;
    } else {
      var _processColor, processedColor = (
        // $FlowIgnore[incompatible-cast] - Type is verified above
        (_processColor = processColor(value)) !== null && _processColor !== void 0 ? _processColor : defaultColor
      ), initColor = defaultColor;
      isRgbaValue(processedColor) ? initColor = processedColor : _this.nativeColor = processedColor, _this.r = new AnimatedValue(initColor.r), _this.g = new AnimatedValue(initColor.g), _this.b = new AnimatedValue(initColor.b), _this.a = new AnimatedValue(initColor.a);
    }
    return (_this.nativeColor || config && config.useNativeDriver) && _this.__makeNative(), _this;
  }
  return _create_class(AnimatedColor2, [
    {
      /**
      * Directly set the value. This will stop any animations running on the value
      * and update all the bound properties.
      */
      key: "setValue",
      value: function(value) {
        var _processColor2, shouldUpdateNodeConfig = !1;
        if (this.__isNative) {
          var nativeTag = this.__getNativeTag();
          NativeAnimatedAPI.setWaitingForIdentifier(nativeTag.toString());
        }
        var processedColor = (_processColor2 = processColor(value)) !== null && _processColor2 !== void 0 ? _processColor2 : defaultColor;
        if (isRgbaValue(processedColor)) {
          var rgbaValue = processedColor;
          this.r.setValue(rgbaValue.r), this.g.setValue(rgbaValue.g), this.b.setValue(rgbaValue.b), this.a.setValue(rgbaValue.a), this.nativeColor != null && (this.nativeColor = null, shouldUpdateNodeConfig = !0);
        } else {
          var nativeColor = processedColor;
          this.nativeColor !== nativeColor && (this.nativeColor = nativeColor, shouldUpdateNodeConfig = !0);
        }
        if (this.__isNative) {
          var _nativeTag = this.__getNativeTag();
          shouldUpdateNodeConfig && NativeAnimatedAPI.updateAnimatedNodeConfig(_nativeTag, this.__getNativeConfig()), NativeAnimatedAPI.unsetWaitingForIdentifier(_nativeTag.toString());
        }
      }
    },
    {
      /**
      * Sets an offset that is applied on top of whatever value is set, whether
      * via `setValue`, an animation, or `Animated.event`. Useful for compensating
      * things like the start of a pan gesture.
      */
      key: "setOffset",
      value: function(offset) {
        this.r.setOffset(offset.r), this.g.setOffset(offset.g), this.b.setOffset(offset.b), this.a.setOffset(offset.a);
      }
    },
    {
      /**
      * Merges the offset value into the base value and resets the offset to zero.
      * The final output of the value is unchanged.
      */
      key: "flattenOffset",
      value: function() {
        this.r.flattenOffset(), this.g.flattenOffset(), this.b.flattenOffset(), this.a.flattenOffset();
      }
    },
    {
      /**
      * Sets the offset value to the base value, and resets the base value to
      * zero. The final output of the value is unchanged.
      */
      key: "extractOffset",
      value: function() {
        this.r.extractOffset(), this.g.extractOffset(), this.b.extractOffset(), this.a.extractOffset();
      }
    },
    {
      /**
      * Adds an asynchronous listener to the value so you can observe updates from
      * animations.  This is useful because there is no way to synchronously read
      * the value because it might be driven natively.
      *
      * Returns a string that serves as an identifier for the listener.
      */
      key: "addListener",
      value: function(callback) {
        var _this = this, id = String(_uniqueId++), jointCallback = function(_ref) {
          var number = _ref.value;
          callback(_this.__getValue());
        };
        return this._listeners[id] = {
          r: this.r.addListener(jointCallback),
          g: this.g.addListener(jointCallback),
          b: this.b.addListener(jointCallback),
          a: this.a.addListener(jointCallback)
        }, id;
      }
    },
    {
      /**
      * Unregister a listener. The `id` param shall match the identifier
      * previously returned by `addListener()`.
      */
      key: "removeListener",
      value: function(id) {
        this.r.removeListener(this._listeners[id].r), this.g.removeListener(this._listeners[id].g), this.b.removeListener(this._listeners[id].b), this.a.removeListener(this._listeners[id].a), delete this._listeners[id];
      }
    },
    {
      /**
      * Remove all registered listeners.
      */
      key: "removeAllListeners",
      value: function() {
        this.r.removeAllListeners(), this.g.removeAllListeners(), this.b.removeAllListeners(), this.a.removeAllListeners(), this._listeners = {};
      }
    },
    {
      /**
      * Stops any running animation or tracking. `callback` is invoked with the
      * final value after stopping the animation, which is useful for updating
      * state to match the animation position with layout.
      */
      key: "stopAnimation",
      value: function(callback) {
        this.r.stopAnimation(), this.g.stopAnimation(), this.b.stopAnimation(), this.a.stopAnimation(), callback && callback(this.__getValue());
      }
    },
    {
      /**
      * Stops any animation and resets the value to its original.
      */
      key: "resetAnimation",
      value: function(callback) {
        this.r.resetAnimation(), this.g.resetAnimation(), this.b.resetAnimation(), this.a.resetAnimation(), callback && callback(this.__getValue());
      }
    },
    {
      key: "__getValue",
      value: function() {
        return this.nativeColor != null ? this.nativeColor : "rgba(" + this.r.__getValue() + ", " + this.g.__getValue() + ", " + this.b.__getValue() + ", " + this.a.__getValue() + ")";
      }
    },
    {
      key: "__attach",
      value: function() {
        this.r.__addChild(this), this.g.__addChild(this), this.b.__addChild(this), this.a.__addChild(this), _get(_get_prototype_of(AnimatedColor2.prototype), "__attach", this).call(this);
      }
    },
    {
      key: "__detach",
      value: function() {
        this.r.__removeChild(this), this.g.__removeChild(this), this.b.__removeChild(this), this.a.__removeChild(this), _get(_get_prototype_of(AnimatedColor2.prototype), "__detach", this).call(this);
      }
    },
    {
      key: "__makeNative",
      value: function(platformConfig) {
        this.r.__makeNative(platformConfig), this.g.__makeNative(platformConfig), this.b.__makeNative(platformConfig), this.a.__makeNative(platformConfig), _get(_get_prototype_of(AnimatedColor2.prototype), "__makeNative", this).call(this, platformConfig);
      }
    },
    {
      key: "__getNativeConfig",
      value: function() {
        return {
          type: "color",
          r: this.r.__getNativeTag(),
          g: this.g.__getNativeTag(),
          b: this.b.__getNativeTag(),
          a: this.a.__getNativeTag(),
          nativeColor: this.nativeColor
        };
      }
    }
  ]), AnimatedColor2;
}(AnimatedWithChildren);
export {
  AnimatedColor as default
};
//# sourceMappingURL=AnimatedColor.js.map
