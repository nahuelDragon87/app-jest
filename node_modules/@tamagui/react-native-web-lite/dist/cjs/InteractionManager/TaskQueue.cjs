var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: !0
    });
  },
  __copyProps = (to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function") for (let key of __getOwnPropNames(from)) !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
    return to;
  };
var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
  value: !0
}), mod);
var TaskQueue_exports = {};
__export(TaskQueue_exports, {
  default: () => TaskQueue_default
});
module.exports = __toCommonJS(TaskQueue_exports);
var import_react_native_web_internals = require("@tamagui/react-native-web-internals");
class TaskQueue {
  _queueStack;
  _onMoreTasks;
  constructor({
    onMoreTasks
  }) {
    this._onMoreTasks = onMoreTasks, this._queueStack = [{
      tasks: [],
      popable: !0
    }];
  }
  enqueue(task) {
    this._getCurrentQueue().push(task);
  }
  enqueueTasks(tasks) {
    tasks.forEach(task => this.enqueue(task));
  }
  cancelTasks(tasksToCancel) {
    this._queueStack = this._queueStack.map(queue => ({
      ...queue,
      tasks: queue.tasks.filter(task => !tasksToCancel.includes(task))
    })).filter((queue, idx) => queue.tasks.length > 0 || idx === 0);
  }
  hasTasksToProcess() {
    return this._getCurrentQueue().length > 0;
  }
  /**
   * Executes the next task in the queue.
   */
  processNext() {
    const queue = this._getCurrentQueue();
    if (queue.length) {
      const task = queue.shift();
      try {
        typeof task == "object" && "gen" in task ? this._genPromise(task) : typeof task == "object" && "run" in task ? task.run() : ((0, import_react_native_web_internals.invariant)(typeof task == "function", `Expected Function, SimpleTask, or PromiseTask, but got:
` + JSON.stringify(task, null, 2)), task());
      } catch (e) {
        throw e instanceof Error && (e.message = "TaskQueue: Error with task " + (task?.name || "") + ": " + e.message), e;
      }
    }
  }
  _getCurrentQueue() {
    const stackIdx = this._queueStack.length - 1,
      queue = this._queueStack[stackIdx];
    return queue.popable && queue.tasks.length === 0 && stackIdx > 0 ? (this._queueStack.pop(), this._getCurrentQueue()) : queue.tasks;
  }
  _genPromise(task) {
    const stackIdx = this._queueStack.push({
        tasks: [],
        popable: !1
      }) - 1,
      stackItem = this._queueStack[stackIdx];
    task.gen().then(() => {
      stackItem.popable = !0, this.hasTasksToProcess() && this._onMoreTasks();
    }).catch(ex => {
      setTimeout(() => {
        throw ex instanceof Error && (ex.message = `TaskQueue: Error resolving Promise in task ${task.name}: ${ex.message}`), ex;
      }, 0);
    });
  }
}
var TaskQueue_default = TaskQueue;