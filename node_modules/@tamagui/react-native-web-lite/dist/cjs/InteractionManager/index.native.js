"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var InteractionManager_exports = {};
__export(InteractionManager_exports, {
  default: () => InteractionManager_default
});
module.exports = __toCommonJS(InteractionManager_exports);
var import_react_native_web_internals = require("@tamagui/react-native-web-internals"), import_EventEmitter = __toESM(require("../vendor/react-native/emitter/_EventEmitter")), import_TaskQueue = __toESM(require("./TaskQueue")), _emitter = new import_EventEmitter.default(), InteractionManager = {
  Events: {
    interactionStart: "interactionStart",
    interactionComplete: "interactionComplete"
  },
  /**
  * Schedule a function to run after all interactions have completed.
  */
  runAfterInteractions(task) {
    var tasks = [], promise = new Promise(function(resolve) {
      _scheduleUpdate(), task && tasks.push(task), tasks.push({
        run: resolve,
        name: "resolve " + (task && task.name || "?")
      }), _taskQueue.enqueueTasks(tasks);
    });
    return {
      then: promise.then.bind(promise),
      done: promise.then.bind(promise),
      cancel: function() {
        _taskQueue.cancelTasks(tasks);
      }
    };
  },
  /**
  * Notify manager that an interaction has started.
  */
  createInteractionHandle() {
    _scheduleUpdate();
    var handle = ++_inc;
    return _addInteractionSet.add(handle), handle;
  },
  /**
  * Notify manager that an interaction has completed.
  */
  clearInteractionHandle(handle) {
    (0, import_react_native_web_internals.invariant)(!!handle, "Must provide a handle to clear."), _scheduleUpdate(), _addInteractionSet.delete(handle), _deleteInteractionSet.add(handle);
  },
  addListener: _emitter.addListener.bind(_emitter),
  /**
  *
  * @param deadline
  */
  setDeadline(deadline) {
    _deadline = deadline;
  }
}, _interactionSet = /* @__PURE__ */ new Set(), _addInteractionSet = /* @__PURE__ */ new Set(), _deleteInteractionSet = /* @__PURE__ */ new Set(), _taskQueue = new import_TaskQueue.default({
  onMoreTasks: _scheduleUpdate
}), _nextUpdateHandle = null, _inc = 0, _deadline = -1;
function _scheduleUpdate() {
  _nextUpdateHandle || (_deadline > 0 ? _nextUpdateHandle = setTimeout(_processUpdate) : _nextUpdateHandle = requestIdleCallback(_processUpdate));
}
function _processUpdate() {
  _nextUpdateHandle = null;
  var interactionCount = _interactionSet.size;
  _addInteractionSet.forEach(function(handle) {
    return _interactionSet.add(handle);
  }), _deleteInteractionSet.forEach(function(handle) {
    return _interactionSet.delete(handle);
  });
  var nextInteractionCount = _interactionSet.size;
  if (interactionCount !== 0 && nextInteractionCount === 0 ? _emitter.emit(InteractionManager.Events.interactionComplete) : interactionCount === 0 && nextInteractionCount !== 0 && _emitter.emit(InteractionManager.Events.interactionStart), nextInteractionCount === 0) {
    for (var begin = Date.now(); _taskQueue.hasTasksToProcess(); )
      if (_taskQueue.processNext(), _deadline > 0 && Date.now() - begin >= _deadline) {
        _scheduleUpdate();
        break;
      }
  }
  _addInteractionSet.clear(), _deleteInteractionSet.clear();
}
var InteractionManager_default = InteractionManager;
//# sourceMappingURL=index.js.map
