"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var VirtualizeUtils_exports = {};
__export(VirtualizeUtils_exports, {
  computeWindowedRenderLimits: () => computeWindowedRenderLimits,
  elementsThatOverlapOffsets: () => elementsThatOverlapOffsets,
  keyExtractor: () => keyExtractor,
  newRangeCount: () => newRangeCount
});
module.exports = __toCommonJS(VirtualizeUtils_exports);
function elementsThatOverlapOffsets(offsets, props, getFrameMetrics) {
  for (var zoomScale = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, itemCount = props.getItemCount(props.data), result = [], offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++)
    for (var currentOffset = offsets[offsetIndex], left = 0, right = itemCount - 1; left <= right; ) {
      var mid = left + (right - left >>> 1), frame = getFrameMetrics(mid, props), scaledOffsetStart = frame.offset * zoomScale, scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;
      if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart)
        right = mid - 1;
      else if (currentOffset > scaledOffsetEnd)
        left = mid + 1;
      else {
        result[offsetIndex] = mid;
        break;
      }
    }
  return result;
}
function newRangeCount(prev, next) {
  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
}
function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {
  var itemCount = props.getItemCount(props.data);
  if (itemCount === 0)
    return {
      first: 0,
      last: -1
    };
  var { offset, velocity, visibleLength, zoomScale = 1 } = scrollMetrics, visibleBegin = Math.max(0, offset), visibleEnd = visibleBegin + visibleLength, overscanLength = (windowSize - 1) * visibleLength, leadFactor = 0.5, fillPreference = velocity > 1 ? "after" : velocity < -1 ? "before" : "none", overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength), overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength), lastItemOffset = getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;
  if (lastItemOffset < overscanBegin)
    return {
      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
      last: itemCount - 1
    };
  var [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets([
    overscanBegin,
    visibleBegin,
    visibleEnd,
    overscanEnd
  ], props, getFrameMetricsApprox, zoomScale);
  overscanFirst = overscanFirst ?? 0, first = first ?? Math.max(0, overscanFirst), overscanLast = overscanLast ?? itemCount - 1, last = last ?? Math.min(overscanLast, first + maxToRenderPerBatch - 1);
  for (var visible = {
    first,
    last
  }, newCellCount = newRangeCount(prev, visible); !(first <= overscanFirst && last >= overscanLast); ) {
    var maxNewCells = newCellCount >= maxToRenderPerBatch, firstWillAddMore = first <= prev.first || first > prev.last, firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore), lastWillAddMore = last >= prev.last || last < prev.first, lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);
    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement)
      break;
    firstShouldIncrement && !(fillPreference === "after" && lastShouldIncrement && lastWillAddMore) && (firstWillAddMore && newCellCount++, first--), lastShouldIncrement && !(fillPreference === "before" && firstShouldIncrement && firstWillAddMore) && (lastWillAddMore && newCellCount++, last++);
  }
  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last))
    throw new Error("Bad window calculation " + JSON.stringify({
      first,
      last,
      itemCount,
      overscanFirst,
      overscanLast,
      visible
    }));
  return {
    first,
    last
  };
}
function keyExtractor(item, index) {
  return typeof item == "object" && (item == null ? void 0 : item.key) != null ? item.key : typeof item == "object" && (item == null ? void 0 : item.id) != null ? item.id : String(index);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  computeWindowedRenderLimits,
  elementsThatOverlapOffsets,
  keyExtractor,
  newRangeCount
});
//# sourceMappingURL=index.js.map
