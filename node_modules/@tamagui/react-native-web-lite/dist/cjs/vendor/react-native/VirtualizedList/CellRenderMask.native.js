"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var CellRenderMask_exports = {};
__export(CellRenderMask_exports, {
  CellRenderMask: () => CellRenderMask
});
module.exports = __toCommonJS(CellRenderMask_exports);
var import_react_native_web_internals = require("@tamagui/react-native-web-internals");
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var CellRenderMask = /* @__PURE__ */ function() {
  "use strict";
  function CellRenderMask2(numCells) {
    _class_call_check(this, CellRenderMask2), _define_property(this, "_numCells", void 0), _define_property(this, "_regions", void 0), (0, import_react_native_web_internals.invariant)(numCells >= 0, "CellRenderMask must contain a non-negative number of cells"), this._numCells = numCells, numCells === 0 ? this._regions = [] : this._regions = [
      {
        first: 0,
        last: numCells - 1,
        isSpacer: !0
      }
    ];
  }
  return _create_class(CellRenderMask2, [
    {
      key: "enumerateRegions",
      value: function() {
        return this._regions;
      }
    },
    {
      key: "addCells",
      value: function(cells) {
        if ((0, import_react_native_web_internals.invariant)(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, "CellRenderMask.addCells called with invalid cell range"), !(cells.last < cells.first)) {
          var [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first), [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);
          if (!(firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer)) {
            var newLeadRegion = [], newTailRegion = [], newMainRegion = {
              ...cells,
              isSpacer: !1
            };
            firstIntersect.first < newMainRegion.first && (firstIntersect.isSpacer ? newLeadRegion.push({
              first: firstIntersect.first,
              last: newMainRegion.first - 1,
              isSpacer: !0
            }) : newMainRegion.first = firstIntersect.first), lastIntersect.last > newMainRegion.last && (lastIntersect.isSpacer ? newTailRegion.push({
              first: newMainRegion.last + 1,
              last: lastIntersect.last,
              isSpacer: !0
            }) : newMainRegion.last = lastIntersect.last);
            var replacementRegions = [
              ...newLeadRegion,
              newMainRegion,
              ...newTailRegion
            ], numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;
            this._regions.splice(firstIntersectIdx, numRegionsToDelete, ...replacementRegions);
          }
        }
      }
    },
    {
      key: "numCells",
      value: function() {
        return this._numCells;
      }
    },
    {
      key: "equals",
      value: function(other) {
        return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every(function(region, i) {
          return region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer;
        });
      }
    },
    {
      key: "_findRegion",
      value: function(cellIdx) {
        for (var firstIdx = 0, lastIdx = this._regions.length - 1; firstIdx <= lastIdx; ) {
          var middleIdx = Math.floor((firstIdx + lastIdx) / 2), middleRegion = this._regions[middleIdx];
          if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last)
            return [
              middleRegion,
              middleIdx
            ];
          cellIdx < middleRegion.first ? lastIdx = middleIdx - 1 : cellIdx > middleRegion.last && (firstIdx = middleIdx + 1);
        }
        (0, import_react_native_web_internals.invariant)(!1, `A region was not found containing cellIdx ${cellIdx}`);
      }
    }
  ]), CellRenderMask2;
}();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CellRenderMask
});
//# sourceMappingURL=CellRenderMask.js.map
