var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: !0
    });
  },
  __copyProps = (to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function") for (let key of __getOwnPropNames(from)) !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
    return to;
  };
var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
  value: !0
}), mod);
var CellRenderMask_exports = {};
__export(CellRenderMask_exports, {
  CellRenderMask: () => CellRenderMask
});
module.exports = __toCommonJS(CellRenderMask_exports);
var import_react_native_web_internals = require("@tamagui/react-native-web-internals");
class CellRenderMask {
  _numCells;
  _regions;
  constructor(numCells) {
    (0, import_react_native_web_internals.invariant)(numCells >= 0, "CellRenderMask must contain a non-negative number of cells"), this._numCells = numCells, numCells === 0 ? this._regions = [] : this._regions = [{
      first: 0,
      last: numCells - 1,
      isSpacer: !0
    }];
  }
  enumerateRegions() {
    return this._regions;
  }
  addCells(cells) {
    if ((0, import_react_native_web_internals.invariant)(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, "CellRenderMask.addCells called with invalid cell range"), cells.last < cells.first) return;
    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first),
      [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);
    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) return;
    const newLeadRegion = [],
      newTailRegion = [],
      newMainRegion = {
        ...cells,
        isSpacer: !1
      };
    firstIntersect.first < newMainRegion.first && (firstIntersect.isSpacer ? newLeadRegion.push({
      first: firstIntersect.first,
      last: newMainRegion.first - 1,
      isSpacer: !0
    }) : newMainRegion.first = firstIntersect.first), lastIntersect.last > newMainRegion.last && (lastIntersect.isSpacer ? newTailRegion.push({
      first: newMainRegion.last + 1,
      last: lastIntersect.last,
      isSpacer: !0
    }) : newMainRegion.last = lastIntersect.last);
    const replacementRegions = [...newLeadRegion, newMainRegion, ...newTailRegion],
      numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;
    this._regions.splice(firstIntersectIdx, numRegionsToDelete, ...replacementRegions);
  }
  numCells() {
    return this._numCells;
  }
  equals(other) {
    return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every((region, i) => region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer);
  }
  _findRegion(cellIdx) {
    let firstIdx = 0,
      lastIdx = this._regions.length - 1;
    for (; firstIdx <= lastIdx;) {
      const middleIdx = Math.floor((firstIdx + lastIdx) / 2),
        middleRegion = this._regions[middleIdx];
      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) return [middleRegion, middleIdx];
      cellIdx < middleRegion.first ? lastIdx = middleIdx - 1 : cellIdx > middleRegion.last && (firstIdx = middleIdx + 1);
    }
    (0, import_react_native_web_internals.invariant)(!1, `A region was not found containing cellIdx ${cellIdx}`);
  }
}