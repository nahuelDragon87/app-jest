"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var check_dep_versions_exports = {};
__export(check_dep_versions_exports, {
  CDVC: () => CDVC
});
module.exports = __toCommonJS(check_dep_versions_exports);
var import_fast_glob = require("fast-glob"), import_js_yaml = require("js-yaml"), import_node_fs = require("node:fs"), import_node_path = require("node:path");
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function calculateVersionsForEachDependency(packages) {
  var depType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_DEP_TYPES, dependenciesToVersionsSeen = /* @__PURE__ */ new Map(), _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
  try {
    for (var _iterator = packages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
      var package_ = _step.value;
      recordDependencyVersionsForPackageJson(dependenciesToVersionsSeen, package_, depType);
    }
  } catch (err) {
    _didIteratorError = !0, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError)
        throw _iteratorError;
    }
  }
  return dependenciesToVersionsSeen;
}
function recordDependencyVersionsForPackageJson(dependenciesToVersionsSeen, package_, depType) {
  if (package_.packageJson.name && package_.packageJson.version && recordDependencyVersion(dependenciesToVersionsSeen, package_.packageJson.name, package_.packageJson.version, package_, !0), depType.includes("dependencies") && package_.packageJson.dependencies) {
    var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _iterator = Object.entries(package_.packageJson.dependencies)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var [dependency, dependencyVersion] = _step.value;
        dependencyVersion && recordDependencyVersion(dependenciesToVersionsSeen, dependency, dependencyVersion, package_);
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
  }
  if (depType.includes("devDependencies") && package_.packageJson.devDependencies) {
    var _iteratorNormalCompletion1 = !0, _didIteratorError1 = !1, _iteratorError1 = void 0;
    try {
      for (var _iterator1 = Object.entries(package_.packageJson.devDependencies)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0) {
        var [dependency1, dependencyVersion1] = _step1.value;
        dependencyVersion1 && recordDependencyVersion(dependenciesToVersionsSeen, dependency1, dependencyVersion1, package_);
      }
    } catch (err) {
      _didIteratorError1 = !0, _iteratorError1 = err;
    } finally {
      try {
        !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
      } finally {
        if (_didIteratorError1)
          throw _iteratorError1;
      }
    }
  }
  if (depType.includes("optionalDependencies") && package_.packageJson.optionalDependencies) {
    var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
    try {
      for (var _iterator2 = Object.entries(package_.packageJson.optionalDependencies)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
        var [dependency2, dependencyVersion2] = _step2.value;
        dependencyVersion2 && recordDependencyVersion(dependenciesToVersionsSeen, dependency2, dependencyVersion2, package_);
      }
    } catch (err) {
      _didIteratorError2 = !0, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
      } finally {
        if (_didIteratorError2)
          throw _iteratorError2;
      }
    }
  }
  if (depType.includes("peerDependencies") && package_.packageJson.peerDependencies) {
    var _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
    try {
      for (var _iterator3 = Object.entries(package_.packageJson.peerDependencies)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
        var [dependency3, dependencyVersion3] = _step3.value;
        dependencyVersion3 && recordDependencyVersion(dependenciesToVersionsSeen, dependency3, dependencyVersion3, package_);
      }
    } catch (err) {
      _didIteratorError3 = !0, _iteratorError3 = err;
    } finally {
      try {
        !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
      } finally {
        if (_didIteratorError3)
          throw _iteratorError3;
      }
    }
  }
  if (depType.includes("resolutions") && package_.packageJson.resolutions) {
    var _iteratorNormalCompletion4 = !0, _didIteratorError4 = !1, _iteratorError4 = void 0;
    try {
      for (var _iterator4 = Object.entries(package_.packageJson.resolutions)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = !0) {
        var [dependency4, dependencyVersion4] = _step4.value;
        dependencyVersion4 && recordDependencyVersion(dependenciesToVersionsSeen, dependency4, dependencyVersion4, package_);
      }
    } catch (err) {
      _didIteratorError4 = !0, _iteratorError4 = err;
    } finally {
      try {
        !_iteratorNormalCompletion4 && _iterator4.return != null && _iterator4.return();
      } finally {
        if (_didIteratorError4)
          throw _iteratorError4;
      }
    }
  }
}
function recordDependencyVersion(dependenciesToVersionsSeen, dependency, version, package_) {
  var isLocalPackageVersion = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  dependenciesToVersionsSeen.has(dependency) || dependenciesToVersionsSeen.set(dependency, []);
  var list = dependenciesToVersionsSeen.get(dependency);
  list && list.push({
    package: package_,
    version,
    isLocalPackageVersion
  });
}
function calculateDependenciesAndVersions(dependencyVersions) {
  return [
    ...dependencyVersions.entries()
  ].sort(function(a, b) {
    return a[0].localeCompare(b[0]);
  }).flatMap(function(param) {
    var [dependency, versionObjectsForDep] = param;
    if (!versionObjectsForDep)
      return [];
    var versions = versionObjectsForDep.filter(function(versionObject) {
      return !versionObject.isLocalPackageVersion;
    }).map(function(versionObject) {
      return versionObject.version;
    }), localPackageVersions = versionObjectsForDep.filter(function(versionObject) {
      return versionObject.isLocalPackageVersion;
    }).map(function(versionObject) {
      return versionObject.version;
    }), allVersionsHaveWorkspacePrefix = versions.every(function(version) {
      return version.startsWith("workspace:");
    }), hasIncompatibilityWithLocalPackageVersion = versions.some(function(version) {
      return localPackageVersions[0] !== version;
    });
    localPackageVersions.length === 1 && !allVersionsHaveWorkspacePrefix && hasIncompatibilityWithLocalPackageVersion && (versions = [
      ...versions,
      ...localPackageVersions
    ]);
    var uniqueVersions = [
      ...new Set(versions)
    ], uniqueVersionsWithInfo = versionsObjectsWithSortedPackages(uniqueVersions, versionObjectsForDep);
    return {
      dependency,
      versions: uniqueVersionsWithInfo
    };
  });
}
function versionsObjectsWithSortedPackages(versions, versionObjects) {
  return versions.map(function(version) {
    var matchingVersionObjects = versionObjects.filter(function(versionObject) {
      return versionObject.version === version;
    });
    return {
      version,
      packages: matchingVersionObjects.map(function(object) {
        return object.package;
      }).sort(function(a, b) {
        return Package.comparator(a, b);
      })
    };
  });
}
var HARDCODED_IGNORED_DEPENDENCIES = /* @__PURE__ */ new Set([
  "//"
]);
function filterOutIgnoredDependencies(mismatchingVersions, ignoredDependencies, includedDependencyPatterns) {
  var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
  try {
    for (var _loop = function() {
      var ignoreDependency = _step.value;
      if (!mismatchingVersions.some(function(mismatchingVersion) {
        return mismatchingVersion.dependency === ignoreDependency;
      }))
        throw new Error(`Specified option '--ignore-dep ${ignoreDependency}', but no version mismatches detected for this dependency.`);
    }, _iterator = ignoredDependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) _loop();
  } catch (err) {
    _didIteratorError = !0, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError)
        throw _iteratorError;
    }
  }
  return ignoredDependencies.length > 0 || includedDependencyPatterns.length > 0 || mismatchingVersions.some(function(mismatchingVersion) {
    return HARDCODED_IGNORED_DEPENDENCIES.has(mismatchingVersion.dependency);
  }) ? mismatchingVersions.filter(function(mismatchingVersion) {
    return !ignoredDependencies.includes(mismatchingVersion.dependency) && includedDependencyPatterns.some(function(ignoreDependencyPattern) {
      return mismatchingVersion.dependency.match(ignoreDependencyPattern);
    }) && !HARDCODED_IGNORED_DEPENDENCIES.has(mismatchingVersion.dependency);
  }) : mismatchingVersions;
}
function getPackages(root, ignorePackages, ignorePackagePatterns, ignorePaths, ignorePathPatterns) {
  if (!Package.exists(root))
    throw new Error("No package.json found at provided path.");
  var packages = accumulatePackages(root, [
    "."
  ]), _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
  try {
    for (var _loop = function() {
      var ignoredPackage = _step.value;
      if (!Package.some(packages, function(package_) {
        return package_.name === ignoredPackage;
      }))
        throw new Error(`Specified option '--ignore-package ${ignoredPackage}', but no such package detected in workspace.`);
    }, _iterator = ignorePackages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) _loop();
  } catch (err) {
    _didIteratorError = !0, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError)
        throw _iteratorError;
    }
  }
  var _iteratorNormalCompletion1 = !0, _didIteratorError1 = !1, _iteratorError1 = void 0;
  try {
    for (var _loop1 = function() {
      var ignoredPackagePattern = _step1.value;
      if (
        // eslint-disable-next-line unicorn/no-array-method-this-argument,unicorn/no-array-callback-reference -- false positive
        !Package.some(packages, function(package_) {
          return ignoredPackagePattern.test(package_.name);
        })
      )
        throw new Error(`Specified option '--ignore-package-pattern ${String(ignoredPackagePattern)}', but no matching packages detected in workspace.`);
    }, _iterator1 = ignorePackagePatterns[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0) _loop1();
  } catch (err) {
    _didIteratorError1 = !0, _iteratorError1 = err;
  } finally {
    try {
      !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
    } finally {
      if (_didIteratorError1)
        throw _iteratorError1;
    }
  }
  var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
  try {
    for (var _loop2 = function() {
      var ignoredPath = _step2.value;
      if (
        // eslint-disable-next-line unicorn/no-array-method-this-argument,unicorn/no-array-callback-reference -- false positive
        !Package.some(packages, function(package_) {
          return package_.pathRelative.includes(ignoredPath);
        })
      )
        throw new Error(`Specified option '--ignore-path ${ignoredPath}', but no matching paths detected in workspace.`);
    }, _iterator2 = ignorePaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) _loop2();
  } catch (err) {
    _didIteratorError2 = !0, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
    } finally {
      if (_didIteratorError2)
        throw _iteratorError2;
    }
  }
  var _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
  try {
    for (var _loop3 = function() {
      var ignoredPathPattern = _step3.value;
      if (
        // eslint-disable-next-line unicorn/no-array-method-this-argument,unicorn/no-array-callback-reference -- false positive
        !Package.some(packages, function(package_) {
          return ignoredPathPattern.test(package_.pathRelative);
        })
      )
        throw new Error(`Specified option '--ignore-path-pattern ${String(ignoredPathPattern)}', but no matching paths detected in workspace.`);
    }, _iterator3 = ignorePathPatterns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) _loop3();
  } catch (err) {
    _didIteratorError3 = !0, _iteratorError3 = err;
  } finally {
    try {
      !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
    } finally {
      if (_didIteratorError3)
        throw _iteratorError3;
    }
  }
  return ignorePackages.length > 0 || ignorePackagePatterns.length > 0 || ignorePaths.length > 0 || ignorePathPatterns.length > 0 ? packages.filter(function(package_) {
    return !ignorePackages.includes(package_.name) && !ignorePackagePatterns.some(function(ignorePackagePattern) {
      return package_.name.match(ignorePackagePattern);
    }) && !ignorePaths.some(function(ignorePath) {
      return package_.pathRelative.includes(ignorePath);
    }) && !ignorePathPatterns.some(function(ignorePathPattern) {
      return package_.pathRelative.match(ignorePathPattern);
    });
  }) : packages;
}
function expandWorkspaces(root, workspacePatterns) {
  return workspacePatterns.flatMap(function(workspace) {
    return workspace.includes("*") ? (0, import_fast_glob.globSync)(workspace, {
      onlyDirectories: !0,
      cwd: root,
      ignore: [
        "**/node_modules"
      ]
    }) : [
      workspace
    ];
  });
}
function accumulatePackages(root, paths) {
  var results = [], _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
  try {
    for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
      var relativePath = _step.value, path = (0, import_node_path.join)(root, relativePath);
      if (Package.exists(path)) {
        var package_ = new Package(path, root);
        results.push(
          // Add the current package.
          package_,
          ...accumulatePackages(path, expandWorkspaces(path, package_.workspacePatterns))
        );
      }
    }
  } catch (err) {
    _didIteratorError = !0, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError)
        throw _iteratorError;
    }
  }
  return results;
}
var Package = /* @__PURE__ */ function() {
  "use strict";
  function Package2(path, pathWorkspace) {
    _class_call_check(this, Package2), _define_property(this, "path", void 0), _define_property(this, "pathWorkspace", void 0), _define_property(this, "pathPackageJson", void 0), _define_property(this, "packageJson", void 0), _define_property(this, "packageJsonEndsInNewline", void 0), _define_property(this, "pnpmWorkspacePackages", void 0), this.path = path, this.pathWorkspace = pathWorkspace, this.pathPackageJson = (0, import_node_path.join)(path, "package.json");
    var packageJsonContents = (0, import_node_fs.readFileSync)(this.pathPackageJson, "utf8");
    this.packageJsonEndsInNewline = packageJsonContents.endsWith(`
`), this.packageJson = JSON.parse(packageJsonContents);
    var pnpmWorkspacePath = (0, import_node_path.join)(path, "pnpm-workspace.yaml");
    if ((0, import_node_fs.existsSync)(pnpmWorkspacePath)) {
      var pnpmWorkspaceContents = (0, import_node_fs.readFileSync)(pnpmWorkspacePath, "utf8"), pnpmWorkspaceYaml = (0, import_js_yaml.load)(pnpmWorkspaceContents);
      this.pnpmWorkspacePackages = pnpmWorkspaceYaml.packages;
    }
  }
  return _create_class(Package2, [
    {
      key: "name",
      get: function() {
        if (this.workspacePatterns.length > 0 && !this.packageJson.name)
          return "(Root)";
        if (!this.packageJson.name)
          throw new Error(`${this.pathPackageJson} missing \`name\``);
        return this.packageJson.name;
      }
    },
    {
      key: "pathRelative",
      get: (
        /** Relative to workspace root. */
        function() {
          return (0, import_node_path.relative)(this.pathWorkspace, this.path);
        }
      )
    },
    {
      key: "workspacePatterns",
      get: function() {
        if (this.packageJson.workspaces) {
          if (Array.isArray(this.packageJson.workspaces))
            return this.packageJson.workspaces;
          if (this.packageJson.workspaces.packages) {
            if (!Array.isArray(this.packageJson.workspaces.packages))
              throw new TypeError("package.json `workspaces.packages` is not a string array.");
            return this.packageJson.workspaces.packages;
          } else
            throw new TypeError("package.json `workspaces` is not a string array.");
        }
        if (this.pnpmWorkspacePackages) {
          if (!Array.isArray(this.pnpmWorkspacePackages))
            throw new TypeError("pnpm-workspace.yaml `packages` is not a string array.");
          return this.pnpmWorkspacePackages;
        }
        return [];
      }
    }
  ], [
    {
      key: "exists",
      value: function(path) {
        var packageJsonPath = (0, import_node_path.join)(path, "package.json");
        return (0, import_node_fs.existsSync)(packageJsonPath);
      }
    },
    {
      key: "some",
      value: function(packages, callback) {
        return packages.some(function(package_) {
          return callback(package_);
        });
      }
    },
    {
      key: "comparator",
      value: function(package1, package2) {
        return package1.name.localeCompare(package2.name);
      }
    }
  ]), Package2;
}(), DEPENDENCY_TYPE = /* @__PURE__ */ function(DEPENDENCY_TYPE2) {
  return DEPENDENCY_TYPE2.dependencies = "dependencies", DEPENDENCY_TYPE2.devDependencies = "devDependencies", DEPENDENCY_TYPE2.optionalDependencies = "optionalDependencies", DEPENDENCY_TYPE2.peerDependencies = "peerDependencies", DEPENDENCY_TYPE2.resolutions = "resolutions", DEPENDENCY_TYPE2;
}(DEPENDENCY_TYPE || {}), DEFAULT_DEP_TYPES = [
  "dependencies",
  "devDependencies",
  "optionalDependencies",
  "resolutions"
];
function check(path) {
  var options = {
    includeDepPattern: [
      "tamagui",
      "react-native-web-lite",
      "react-native-web-internals"
    ]
  };
  if (options && options.depType && options.depType.some(function(dt) {
    return !Object.keys(DEPENDENCY_TYPE).includes(dt);
  }))
    throw new Error(`Invalid depType provided. Choices are: ${Object.keys(DEPENDENCY_TYPE).join(", ")}.`);
  var optionsWithDefaults = {
    fix: !1,
    ignoreDep: [],
    includeDepPattern: [],
    ignorePackage: [],
    ignorePackagePattern: [],
    ignorePath: [],
    ignorePathPattern: [],
    ...options,
    // Fallback to default if no depType(s) provided.
    depType: options && options.depType && options.depType.length > 0 ? options.depType : DEFAULT_DEP_TYPES
  }, packages = getPackages(path, optionsWithDefaults.ignorePackage, optionsWithDefaults.ignorePackagePattern.map(function(s) {
    return new RegExp(s);
  }), optionsWithDefaults.ignorePath, optionsWithDefaults.ignorePathPattern.map(function(s) {
    return new RegExp(s);
  })), dependencies = calculateVersionsForEachDependency(packages, optionsWithDefaults.depType.map(function(dt) {
    return DEPENDENCY_TYPE[dt];
  })), dependenciesAndVersions = calculateDependenciesAndVersions(dependencies), dependenciesAndVersionsWithMismatches = dependenciesAndVersions.filter(function(param) {
    var { versions } = param;
    return versions.length > 1;
  }), dependenciesAndVersionsWithoutIgnored = filterOutIgnoredDependencies(dependenciesAndVersions, optionsWithDefaults.ignoreDep, optionsWithDefaults.includeDepPattern.map(function(s) {
    return new RegExp(s);
  })), dependenciesAndVersionsMismatchesWithoutIgnored = filterOutIgnoredDependencies(dependenciesAndVersionsWithMismatches, optionsWithDefaults.ignoreDep, optionsWithDefaults.includeDepPattern.map(function(s) {
    return new RegExp(s);
  }));
  return {
    // Information about all dependencies.
    dependencies: Object.fromEntries(dependenciesAndVersionsWithoutIgnored.map(function(param) {
      var { dependency, versions } = param;
      return [
        dependency,
        {
          isMismatching: dependenciesAndVersionsMismatchesWithoutIgnored.some(function(dep) {
            return dep.dependency === dependency;
          }),
          versions
        }
      ];
    }))
  };
}
var CDVC = /* @__PURE__ */ function() {
  "use strict";
  function CDVC2(path) {
    _class_call_check(this, CDVC2), _define_property(this, "dependencies", void 0);
    var { dependencies } = check(path);
    this.dependencies = dependencies;
  }
  return _create_class(CDVC2, [
    {
      key: "toMismatchSummary",
      value: function() {
        return dependenciesToMismatchSummary(this.dependencies);
      }
    },
    {
      key: "getDependencies",
      value: function() {
        var _this = this;
        return Object.keys(this.dependencies).map(function(dependency) {
          return _this.getDependency(dependency);
        });
      }
    },
    {
      key: "getDependency",
      value: function(name) {
        return {
          name,
          isMismatching: this.dependencies[name].isMismatching,
          versions: this.dependencies[name].versions.map(function(version) {
            return {
              version: version.version,
              packages: version.packages.map(function(package_) {
                return {
                  pathRelative: package_.pathRelative
                };
              })
            };
          })
        };
      }
    },
    {
      key: "hasMismatchingDependencies",
      get: function() {
        return Object.values(this.dependencies).some(function(dep) {
          return dep.isMismatching;
        });
      }
    }
  ]), CDVC2;
}();
function dependenciesToMismatchSummary(dependencies) {
  var mismatchingDependencyVersions = Object.entries(dependencies).filter(function(param) {
    var [, value] = param;
    return value.isMismatching;
  }).map(function(param) {
    var [dependency, value] = param;
    return {
      dependency,
      versions: value.versions
    };
  });
  if (mismatchingDependencyVersions.length === 0)
    return "";
  var tables = mismatchingDependencyVersions.map(function(object) {
    return `${object.dependency} - ${object.versions.map(function(v) {
      return `${v.version}`;
    }).join(", ")}`;
  }).join("");
  return [
    `Found ${mismatchingDependencyVersions.length} ${mismatchingDependencyVersions.length === 1 ? "dependency" : "dependencies"} with mismatching versions across the workspace.`,
    tables
  ].join(`
`);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CDVC
});
//# sourceMappingURL=check-dep-versions.js.map
