var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var extractToClassNames_exports = {};
__export(extractToClassNames_exports, {
  extractToClassNames: () => extractToClassNames
});
module.exports = __toCommonJS(extractToClassNames_exports);
var path = __toESM(require("node:path")), util = __toESM(require("node:util")), import_generator = __toESM(require("@babel/generator")), t = __toESM(require("@babel/types")), helpers = __toESM(require("@tamagui/helpers")), import_requireTamaguiCore = require("../helpers/requireTamaguiCore"), import_babelParse = require("./babelParse"), import_buildClassName = require("./buildClassName"), import_createLogger = require("./createLogger"), import_ensureImportingConcat = require("./ensureImportingConcat"), import_extractHelpers = require("./extractHelpers"), import_extractMediaStyle = require("./extractMediaStyle"), import_hoistClassNames = require("./hoistClassNames"), import_propsToFontFamilyCache = require("./propsToFontFamilyCache"), import_timer = require("./timer");
const mergeStyleGroups = {
  shadowOpacity: !0,
  shadowRadius: !0,
  shadowColor: !0,
  shadowOffset: !0
};
async function extractToClassNames({
  extractor,
  source,
  sourcePath = "",
  options,
  shouldPrintDebug
}) {
  const tm = (0, import_timer.timer)(), { getStylesAtomic } = (0, import_requireTamaguiCore.requireTamaguiCore)("web");
  if (sourcePath.includes("node_modules"))
    return null;
  if (shouldPrintDebug && console.warn(`--- ${sourcePath} --- 

`), typeof source != "string")
    throw new Error("`source` must be a string of javascript");
  if (!path.isAbsolute(sourcePath))
    throw new Error(
      "`sourcePath` must be an absolute path to a .js file, got: " + sourcePath
    );
  /.[tj]sx?$/i.test(sourcePath || "") || console.warn(`${sourcePath.slice(0, 100)} - bad filename.`), !options.disableExtraction && !options._disableLoadTamagui && await extractor.loadTamagui(options);
  const printLog = (0, import_createLogger.createLogger)(sourcePath, options);
  let ast;
  try {
    ast = (0, import_babelParse.babelParse)(source, sourcePath);
  } catch (err) {
    throw console.error("babel parse error:", sourcePath.slice(0, 100)), err;
  }
  tm.mark("babel-parse", shouldPrintDebug === "verbose");
  const cssMap = /* @__PURE__ */ new Map(), existingHoists = {};
  let hasFlattened = !1;
  const res = await extractor.parse(ast, {
    shouldPrintDebug,
    ...options,
    platform: "web",
    sourcePath,
    extractStyledDefinitions: !0,
    onStyleRule(identifier, rules) {
      const css = rules.join(";");
      shouldPrintDebug && console.info(`adding styled() rule: .${identifier} ${css}`), cssMap.set(`.${identifier}`, { css, commentTexts: [] });
    },
    getFlattenedNode: ({ tag }) => (hasFlattened = !0, tag),
    onExtractTag: ({
      parserProps,
      attrs,
      node,
      attemptEval,
      jsxPath,
      originalNodeName,
      filePath,
      lineNumbers,
      programPath,
      isFlattened,
      staticConfig
    }) => {
      if (staticConfig.acceptsClassName === !1) {
        shouldPrintDebug && console.info("bail, acceptsClassName is false");
        return;
      }
      const didFlattenThisTag = hasFlattened;
      hasFlattened = !1;
      let finalClassNames = [];
      const finalAttrs = [];
      let finalStyles = [], viewStyles = {};
      for (const attr of attrs)
        attr.type === "style" && (viewStyles = {
          ...viewStyles,
          ...attr.value
        });
      const ensureNeededPrevStyle = (style) => {
        if (!Object.keys(style).some((key) => mergeStyleGroups[key]))
          return style;
        for (const k in mergeStyleGroups)
          k in viewStyles && (style[k] = style[k] ?? viewStyles[k]);
        return style;
      }, addStyles = (style) => {
        if (!style) return [];
        const styleWithPrev = ensureNeededPrevStyle(style), res2 = getStylesAtomic(styleWithPrev);
        return res2.length && (finalStyles = [...finalStyles, ...res2]), res2;
      };
      let lastMediaImportance = 1;
      for (const attr of attrs)
        switch (attr.type) {
          case "style": {
            if (isFlattened) {
              const styles2 = addStyles(attr.value), newFontFamily = (0, import_propsToFontFamilyCache.getFontFamilyClassNameFromProps)(attr.value) || "", newClassNames = helpers.concatClassName(
                styles2.map((x) => x[helpers.StyleObjectIdentifier]).join(" ") + newFontFamily
              ), existing = finalClassNames.find(
                (x) => x.type == "StringLiteral"
              );
              if (existing) {
                let previous = existing.value;
                newFontFamily && (shouldPrintDebug && console.info(` newFontFamily: ${newFontFamily}`), previous = previous.replace(/font_[a-z]+/i, "")), existing.value = `${previous} ${newClassNames}`;
              } else
                finalClassNames = [...finalClassNames, t.stringLiteral(newClassNames)];
            } else {
              const styles2 = getStylesAtomic(attr.value);
              finalStyles = [...finalStyles, ...styles2];
              for (const style of styles2) {
                const prop = style[helpers.StyleObjectPseudo] ? `${style[helpers.StyleObjectProperty]}-${style[helpers.StyleObjectPseudo]}` : style[helpers.StyleObjectProperty];
                finalAttrs.push(
                  t.jsxAttribute(
                    t.jsxIdentifier(prop),
                    t.stringLiteral(style[helpers.StyleObjectIdentifier])
                  )
                );
              }
            }
            break;
          }
          case "attr": {
            const val = attr.value;
            if (t.isJSXSpreadAttribute(val))
              (0, import_extractHelpers.isSimpleSpread)(val) && finalClassNames.push(
                t.logicalExpression(
                  "&&",
                  val.argument,
                  t.memberExpression(val.argument, t.identifier("className"))
                )
              );
            else if (val.name.name === "className") {
              const value = val.value;
              if (value)
                try {
                  const evaluatedValue = attemptEval(value);
                  finalClassNames.push(t.stringLiteral(evaluatedValue));
                } catch {
                  finalClassNames.push(value.expression);
                }
              continue;
            }
            finalAttrs.push(val);
            break;
          }
          case "ternary": {
            const mediaExtraction = (0, import_extractMediaStyle.extractMediaStyle)(
              parserProps,
              attr.value,
              jsxPath,
              extractor.getTamagui(),
              sourcePath || "",
              lastMediaImportance,
              shouldPrintDebug
            );
            if (shouldPrintDebug && mediaExtraction && console.info(
              "ternary (mediaStyles)",
              mediaExtraction.ternaryWithoutMedia?.inlineMediaQuery ?? "",
              mediaExtraction.mediaStyles.map((x) => x[helpers.StyleObjectIdentifier]).join(".")
            ), !mediaExtraction) {
              shouldPrintDebug && mediaExtraction && console.info("add ternary"), addTernaryStyle(
                attr.value,
                addStyles(attr.value.consequent),
                addStyles(attr.value.alternate)
              );
              continue;
            }
            lastMediaImportance++, mediaExtraction.mediaStyles && (finalStyles = [...finalStyles, ...mediaExtraction.mediaStyles]), mediaExtraction.ternaryWithoutMedia ? addTernaryStyle(
              mediaExtraction.ternaryWithoutMedia,
              mediaExtraction.mediaStyles,
              []
            ) : finalClassNames = [
              ...finalClassNames,
              ...mediaExtraction.mediaStyles.map(
                (x) => t.stringLiteral(x[helpers.StyleObjectIdentifier])
              )
            ];
            break;
          }
        }
      function addTernaryStyle(ternary, a, b) {
        const cCN = a.map((x) => x[helpers.StyleObjectIdentifier]).join(" "), aCN = b.map((x) => x[helpers.StyleObjectIdentifier]).join(" ");
        a.length && b.length ? finalClassNames.push(
          t.conditionalExpression(
            ternary.test,
            t.stringLiteral(cCN),
            t.stringLiteral(aCN)
          )
        ) : finalClassNames.push(
          t.conditionalExpression(
            ternary.test,
            t.stringLiteral(" " + cCN),
            t.stringLiteral(" " + aCN)
          )
        );
      }
      if (shouldPrintDebug === "verbose" && console.info(`  finalClassNames AST
`, JSON.stringify(finalClassNames, null, 2)), node.attributes = finalAttrs, finalClassNames.length) {
        const extraClassNames = (() => {
          let value = "";
          return isFlattened && (process.env.TAMAGUI_DEBUG_OPTIMIZATIONS && (value += "is_tamagui_flattened"), staticConfig.componentName && (value += ` is_${staticConfig.componentName}`)), value;
        })(), names = (0, import_buildClassName.buildClassName)(finalClassNames, extraClassNames), nameExpr = names ? (0, import_hoistClassNames.hoistClassNames)(jsxPath, existingHoists, names) : null;
        let expr = nameExpr;
        if (nameExpr && !t.isIdentifier(nameExpr) && didFlattenThisTag) {
          (0, import_ensureImportingConcat.ensureImportingConcat)(programPath);
          const simpleSpreads = attrs.filter((x) => x.type === "attr" && t.isJSXSpreadAttribute(x.value) && (0, import_extractHelpers.isSimpleSpread)(x.value));
          expr = t.callExpression(t.identifier("concatClassName"), [
            expr,
            ...simpleSpreads.map((val) => val.value.argument)
          ]);
        }
        node.attributes.push(
          t.jsxAttribute(t.jsxIdentifier("className"), t.jsxExpressionContainer(expr))
        );
      }
      const comment = util.format(
        "/* %s:%s (%s) */",
        filePath,
        lineNumbers,
        originalNodeName
      );
      for (const styleObject of finalStyles) {
        const identifier = styleObject[helpers.StyleObjectIdentifier], rules = styleObject[helpers.StyleObjectRules], className = `.${identifier}`;
        if (cssMap.has(className)) {
          if (comment) {
            const val = cssMap.get(className);
            val.commentTexts.push(comment), cssMap.set(className, val);
          }
        } else rules.length && cssMap.set(className, {
          css: rules.join(`
`),
          commentTexts: [comment]
        });
      }
    }
  });
  if (!res || !res.modified && !res.optimized && !res.flattened && !res.styled)
    return shouldPrintDebug && console.info("no res or none modified", res), null;
  const styles = Array.from(cssMap.values()).map((x) => x.css).join(`
`).trim(), result = (0, import_generator.default)(
    ast,
    {
      concise: !1,
      filename: sourcePath,
      // this makes the debug output terrible, and i think sourcemap works already
      retainLines: !1,
      sourceFileName: sourcePath,
      sourceMaps: !0
    },
    source
  );
  return shouldPrintDebug && (console.info(
    `
 -------- output code ------- 

`,
    result.code.split(`
`).filter((x) => !x.startsWith("//")).join(`
`)
  ), console.info(`
 -------- output style -------- 

`, styles)), printLog(res), {
    ast,
    styles,
    js: result.code,
    map: result.map
  };
}
//# sourceMappingURL=extractToClassNames.js.map
