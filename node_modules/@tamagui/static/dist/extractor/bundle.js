var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var bundle_exports = {};
__export(bundle_exports, {
  esbuildIgnoreFilesRegex: () => esbuildIgnoreFilesRegex,
  esbuildLoaderConfig: () => esbuildLoaderConfig,
  esbundleTamaguiConfig: () => esbundleTamaguiConfig
});
module.exports = __toCommonJS(bundle_exports);
var import_node_path = require("node:path"), import_esbuild = __toESM(require("esbuild")), FS = __toESM(require("fs-extra")), import_esbuildAliasPlugin = require("./esbuildAliasPlugin"), import_loadTamagui = require("./loadTamagui"), import_esbuildTsconfigPaths = require("./esbuildTsconfigPaths");
const esbuildLoaderConfig = {
  ".js": "jsx",
  ".png": "dataurl",
  ".jpg": "dataurl",
  ".jpeg": "dataurl",
  ".svg": "dataurl",
  ".gif": "dataurl",
  ".webp": "dataurl",
  ".woff2": "dataurl",
  ".woff": "dataurl",
  ".eot": "dataurl",
  ".otf": "dataurl",
  ".ttf": "dataurl",
  ".mp4": "file",
  ".mpeg4": "file",
  ".mov": "file",
  ".avif": "file",
  ".wmv": "file",
  ".webm": "file",
  ".wav": "file",
  ".aac": "file",
  ".ogg": "file",
  ".flac": "file",
  ".node": "empty"
}, dataExtensions = Object.keys(esbuildLoaderConfig).filter(
  (k) => esbuildLoaderConfig[k] === "file" || esbuildLoaderConfig[k] === "dataurl"
).map((k) => k.slice(1)), esbuildIgnoreFilesRegex = new RegExp(`.(${dataExtensions.join("|")})$`, "i");
function getESBuildConfig({ entryPoints, resolvePlatformSpecificEntries, ...options }, platform, aliases) {
  return process.env.DEBUG?.startsWith("tamagui") && console.info("Building", entryPoints), {
    bundle: !0,
    entryPoints: resolvePlatformSpecificEntries ? entryPoints.map(import_loadTamagui.resolveWebOrNativeSpecificEntry) : entryPoints,
    format: "cjs",
    target: "node20",
    jsx: "transform",
    jsxFactory: "react",
    allowOverwrite: !0,
    keepNames: !0,
    resolveExtensions: [
      ".web.tsx",
      ".web.ts",
      ".web.jsx",
      ".web.js",
      ".tsx",
      ".ts",
      ".jsx",
      ".js"
    ],
    platform: "node",
    tsconfigRaw: {
      compilerOptions: {
        jsx: "react-jsx"
      }
    },
    loader: esbuildLoaderConfig,
    logLevel: "warning",
    plugins: [
      (0, import_esbuildTsconfigPaths.TsconfigPathsPlugin)(),
      {
        name: "external",
        setup(build) {
          build.onResolve({ filter: /@tamagui\/core/ }, (args) => ({
            path: platform === "native" ? "@tamagui/core/native" : "@tamagui/core",
            external: !0
          })), build.onResolve({ filter: /react-native\/package.json$/ }, (args) => ({
            path: "react-native/package.json",
            external: !0
          })), build.onResolve({ filter: /@tamagui\/web/ }, (args) => ({
            path: platform === "native" ? "@tamagui/core/native" : "@tamagui/core",
            external: !0
          })), build.onResolve({ filter: /^(react-native|react-native\/.*)$/ }, (args) => ({
            path: "@tamagui/react-native-web-lite",
            external: !0
          })), build.onResolve({ filter: /react-native-reanimated/ }, (args) => ({
            path: "react-native-reanimated",
            external: !0
          }));
        }
      },
      (0, import_esbuildAliasPlugin.esbuildAliasPlugin)({
        ...aliases
      })
    ],
    ...options
  };
}
async function esbundleTamaguiConfig(props, platform, aliases) {
  await asyncLock(props);
  const config = getESBuildConfig(props, platform, aliases);
  return await import_esbuild.default.build(config);
}
async function asyncLock(props) {
  const lockFile = (0, import_node_path.join)((0, import_node_path.dirname)(props.outfile), (0, import_node_path.basename)(props.outfile, ".lock")), lockStat = await FS.stat(lockFile).catch(() => {
  });
  if ((lockStat ? (/* @__PURE__ */ new Date()).getTime() - new Date(lockStat.mtime).getTime() : Number.POSITIVE_INFINITY) < 500) {
    process.env.DEBUG?.startsWith("tamagui") && console.info("Waiting for existing build", props.entryPoints);
    let tries = 5;
    for (; tries--; ) {
      if (await FS.pathExists(props.outfile))
        return;
      await new Promise((res) => setTimeout(res, 50));
    }
  }
  FS.writeFile(lockFile, "");
}
//# sourceMappingURL=bundle.js.map
