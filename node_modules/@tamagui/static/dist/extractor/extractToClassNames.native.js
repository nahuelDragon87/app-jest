"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var extractToClassNames_exports = {};
__export(extractToClassNames_exports, {
  extractToClassNames: () => extractToClassNames
});
module.exports = __toCommonJS(extractToClassNames_exports);
var path = __toESM(require("node:path")), util = __toESM(require("node:util")), import_generator = __toESM(require("@babel/generator")), t = __toESM(require("@babel/types")), helpers = __toESM(require("@tamagui/helpers")), import_requireTamaguiCore = require("../helpers/requireTamaguiCore"), import_babelParse = require("./babelParse"), import_buildClassName = require("./buildClassName"), import_createLogger = require("./createLogger"), import_ensureImportingConcat = require("./ensureImportingConcat"), import_extractHelpers = require("./extractHelpers"), import_extractMediaStyle = require("./extractMediaStyle"), import_hoistClassNames = require("./hoistClassNames"), import_propsToFontFamilyCache = require("./propsToFontFamilyCache"), import_timer = require("./timer"), mergeStyleGroups = {
  shadowOpacity: !0,
  shadowRadius: !0,
  shadowColor: !0,
  shadowOffset: !0
};
async function extractToClassNames(param) {
  var { extractor, source, sourcePath = "", options, shouldPrintDebug } = param, tm = (0, import_timer.timer)(), { getStylesAtomic } = (0, import_requireTamaguiCore.requireTamaguiCore)("web");
  if (sourcePath.includes("node_modules"))
    return null;
  if (shouldPrintDebug && console.warn(`--- ${sourcePath} --- 

`), typeof source != "string")
    throw new Error("`source` must be a string of javascript");
  if (!path.isAbsolute(sourcePath))
    throw new Error("`sourcePath` must be an absolute path to a .js file, got: " + sourcePath);
  /.[tj]sx?$/i.test(sourcePath || "") || console.warn(`${sourcePath.slice(0, 100)} - bad filename.`), !options.disableExtraction && !options._disableLoadTamagui && await extractor.loadTamagui(options);
  var printLog = (0, import_createLogger.createLogger)(sourcePath, options), ast;
  try {
    ast = (0, import_babelParse.babelParse)(source, sourcePath);
  } catch (err) {
    throw console.error("babel parse error:", sourcePath.slice(0, 100)), err;
  }
  tm.mark("babel-parse", shouldPrintDebug === "verbose");
  var cssMap = /* @__PURE__ */ new Map(), existingHoists = {}, hasFlattened = !1, res = await extractor.parse(ast, {
    shouldPrintDebug,
    ...options,
    platform: "web",
    sourcePath,
    extractStyledDefinitions: !0,
    onStyleRule(identifier, rules) {
      var css = rules.join(";");
      shouldPrintDebug && console.info(`adding styled() rule: .${identifier} ${css}`), cssMap.set(`.${identifier}`, {
        css,
        commentTexts: []
      });
    },
    getFlattenedNode: function(param2) {
      var { tag } = param2;
      return hasFlattened = !0, tag;
    },
    onExtractTag: function(param2) {
      var { parserProps, attrs, node, attemptEval, jsxPath, originalNodeName, filePath, lineNumbers, programPath, isFlattened, staticConfig } = param2;
      if (staticConfig.acceptsClassName === !1) {
        shouldPrintDebug && console.info("bail, acceptsClassName is false");
        return;
      }
      var didFlattenThisTag = hasFlattened;
      hasFlattened = !1;
      var finalClassNames = [], finalAttrs = [], finalStyles = [], viewStyles = {}, _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
      try {
        for (var _iterator = attrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
          var attr = _step.value;
          attr.type === "style" && (viewStyles = {
            ...viewStyles,
            ...attr.value
          });
        }
      } catch (err) {
        _didIteratorError = !0, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError)
            throw _iteratorError;
        }
      }
      var ensureNeededPrevStyle = function(style2) {
        var keys = Object.keys(style2);
        if (!keys.some(function(key) {
          return mergeStyleGroups[key];
        }))
          return style2;
        for (var k in mergeStyleGroups)
          if (k in viewStyles) {
            var _style_k;
            style2[k] = (_style_k = style2[k]) !== null && _style_k !== void 0 ? _style_k : viewStyles[k];
          }
        return style2;
      }, addStyles = function(style2) {
        if (!style2) return [];
        var styleWithPrev = ensureNeededPrevStyle(style2), res2 = getStylesAtomic(styleWithPrev);
        return res2.length && (finalStyles = [
          ...finalStyles,
          ...res2
        ]), res2;
      }, lastMediaImportance = 1, _iteratorNormalCompletion1 = !0, _didIteratorError1 = !1, _iteratorError1 = void 0;
      try {
        for (var _iterator1 = attrs[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0) {
          var attr1 = _step1.value;
          switch (attr1.type) {
            case "style": {
              if (isFlattened) {
                var styles1 = addStyles(attr1.value), newFontFamily = (0, import_propsToFontFamilyCache.getFontFamilyClassNameFromProps)(attr1.value) || "", newClassNames = helpers.concatClassName(styles1.map(function(x) {
                  return x[helpers.StyleObjectIdentifier];
                }).join(" ") + newFontFamily), existing = finalClassNames.find(function(x) {
                  return x.type == "StringLiteral";
                });
                if (existing) {
                  var previous = existing.value;
                  newFontFamily && (shouldPrintDebug && console.info(` newFontFamily: ${newFontFamily}`), previous = previous.replace(/font_[a-z]+/i, "")), existing.value = `${previous} ${newClassNames}`;
                } else
                  finalClassNames = [
                    ...finalClassNames,
                    t.stringLiteral(newClassNames)
                  ];
              } else {
                var styles2 = getStylesAtomic(attr1.value);
                finalStyles = [
                  ...finalStyles,
                  ...styles2
                ];
                var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
                try {
                  for (var _iterator2 = styles2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
                    var style = _step2.value, prop = style[helpers.StyleObjectPseudo] ? `${style[helpers.StyleObjectProperty]}-${style[helpers.StyleObjectPseudo]}` : style[helpers.StyleObjectProperty];
                    finalAttrs.push(t.jsxAttribute(t.jsxIdentifier(prop), t.stringLiteral(style[helpers.StyleObjectIdentifier])));
                  }
                } catch (err) {
                  _didIteratorError2 = !0, _iteratorError2 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
                  } finally {
                    if (_didIteratorError2)
                      throw _iteratorError2;
                  }
                }
              }
              break;
            }
            case "attr": {
              var val = attr1.value;
              if (t.isJSXSpreadAttribute(val))
                (0, import_extractHelpers.isSimpleSpread)(val) && finalClassNames.push(t.logicalExpression("&&", val.argument, t.memberExpression(val.argument, t.identifier("className"))));
              else if (val.name.name === "className") {
                var value = val.value;
                if (value)
                  try {
                    var evaluatedValue = attemptEval(value);
                    finalClassNames.push(t.stringLiteral(evaluatedValue));
                  } catch {
                    finalClassNames.push(value.expression);
                  }
                continue;
              }
              finalAttrs.push(val);
              break;
            }
            case "ternary": {
              var mediaExtraction = (0, import_extractMediaStyle.extractMediaStyle)(parserProps, attr1.value, jsxPath, extractor.getTamagui(), sourcePath || "", lastMediaImportance, shouldPrintDebug);
              if (shouldPrintDebug && mediaExtraction) {
                var _mediaExtraction_ternaryWithoutMedia, _mediaExtraction_ternaryWithoutMedia_inlineMediaQuery;
                console.info("ternary (mediaStyles)", (_mediaExtraction_ternaryWithoutMedia_inlineMediaQuery = (_mediaExtraction_ternaryWithoutMedia = mediaExtraction.ternaryWithoutMedia) === null || _mediaExtraction_ternaryWithoutMedia === void 0 ? void 0 : _mediaExtraction_ternaryWithoutMedia.inlineMediaQuery) !== null && _mediaExtraction_ternaryWithoutMedia_inlineMediaQuery !== void 0 ? _mediaExtraction_ternaryWithoutMedia_inlineMediaQuery : "", mediaExtraction.mediaStyles.map(function(x) {
                  return x[helpers.StyleObjectIdentifier];
                }).join("."));
              }
              if (!mediaExtraction) {
                shouldPrintDebug && mediaExtraction && console.info("add ternary"), addTernaryStyle(attr1.value, addStyles(attr1.value.consequent), addStyles(attr1.value.alternate));
                continue;
              }
              lastMediaImportance++, mediaExtraction.mediaStyles && (finalStyles = [
                ...finalStyles,
                ...mediaExtraction.mediaStyles
              ]), mediaExtraction.ternaryWithoutMedia ? addTernaryStyle(mediaExtraction.ternaryWithoutMedia, mediaExtraction.mediaStyles, []) : finalClassNames = [
                ...finalClassNames,
                ...mediaExtraction.mediaStyles.map(function(x) {
                  return t.stringLiteral(x[helpers.StyleObjectIdentifier]);
                })
              ];
              break;
            }
          }
        }
      } catch (err) {
        _didIteratorError1 = !0, _iteratorError1 = err;
      } finally {
        try {
          !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
        } finally {
          if (_didIteratorError1)
            throw _iteratorError1;
        }
      }
      function addTernaryStyle(ternary, a, b) {
        var cCN = a.map(function(x) {
          return x[helpers.StyleObjectIdentifier];
        }).join(" "), aCN = b.map(function(x) {
          return x[helpers.StyleObjectIdentifier];
        }).join(" ");
        a.length && b.length ? finalClassNames.push(t.conditionalExpression(ternary.test, t.stringLiteral(cCN), t.stringLiteral(aCN))) : finalClassNames.push(t.conditionalExpression(ternary.test, t.stringLiteral(" " + cCN), t.stringLiteral(" " + aCN)));
      }
      if (shouldPrintDebug === "verbose" && console.info(`  finalClassNames AST
`, JSON.stringify(finalClassNames, null, 2)), node.attributes = finalAttrs, finalClassNames.length) {
        var extraClassNames = function() {
          var value2 = "";
          return isFlattened && (process.env.TAMAGUI_DEBUG_OPTIMIZATIONS && (value2 += "is_tamagui_flattened"), staticConfig.componentName && (value2 += ` is_${staticConfig.componentName}`)), value2;
        }(), names = (0, import_buildClassName.buildClassName)(finalClassNames, extraClassNames), nameExpr = names ? (0, import_hoistClassNames.hoistClassNames)(jsxPath, existingHoists, names) : null, expr = nameExpr;
        if (nameExpr && !t.isIdentifier(nameExpr) && didFlattenThisTag) {
          (0, import_ensureImportingConcat.ensureImportingConcat)(programPath);
          var simpleSpreads = attrs.filter(function(x) {
            return x.type === "attr" && t.isJSXSpreadAttribute(x.value) && (0, import_extractHelpers.isSimpleSpread)(x.value);
          });
          expr = t.callExpression(t.identifier("concatClassName"), [
            expr,
            ...simpleSpreads.map(function(val2) {
              return val2.value.argument;
            })
          ]);
        }
        node.attributes.push(t.jsxAttribute(t.jsxIdentifier("className"), t.jsxExpressionContainer(expr)));
      }
      var comment = util.format("/* %s:%s (%s) */", filePath, lineNumbers, originalNodeName), _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
      try {
        for (var _iterator3 = finalStyles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
          var styleObject = _step3.value, identifier = styleObject[helpers.StyleObjectIdentifier], rules = styleObject[helpers.StyleObjectRules], className = `.${identifier}`;
          if (cssMap.has(className)) {
            if (comment) {
              var val1 = cssMap.get(className);
              val1.commentTexts.push(comment), cssMap.set(className, val1);
            }
          } else rules.length && cssMap.set(className, {
            css: rules.join(`
`),
            commentTexts: [
              comment
            ]
          });
        }
      } catch (err) {
        _didIteratorError3 = !0, _iteratorError3 = err;
      } finally {
        try {
          !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
        } finally {
          if (_didIteratorError3)
            throw _iteratorError3;
        }
      }
    }
  });
  if (!res || !res.modified && !res.optimized && !res.flattened && !res.styled)
    return shouldPrintDebug && console.info("no res or none modified", res), null;
  var styles = Array.from(cssMap.values()).map(function(x) {
    return x.css;
  }).join(`
`).trim(), result = (0, import_generator.default)(ast, {
    concise: !1,
    filename: sourcePath,
    // this makes the debug output terrible, and i think sourcemap works already
    retainLines: !1,
    sourceFileName: sourcePath,
    sourceMaps: !0
  }, source);
  return shouldPrintDebug && (console.info(`
 -------- output code ------- 

`, result.code.split(`
`).filter(function(x) {
    return !x.startsWith("//");
  }).join(`
`)), console.info(`
 -------- output style -------- 

`, styles)), printLog(res), {
    ast,
    styles,
    js: result.code,
    map: result.map
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  extractToClassNames
});
//# sourceMappingURL=extractToClassNames.js.map
