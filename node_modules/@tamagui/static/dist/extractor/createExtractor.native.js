"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var createExtractor_exports = {};
__export(createExtractor_exports, {
  createExtractor: () => createExtractor
});
module.exports = __toCommonJS(createExtractor_exports);
var import_traverse = __toESM(require("@babel/traverse")), t = __toESM(require("@babel/types")), import_cli_color = require("@tamagui/cli-color"), import_web = require("@tamagui/web"), import_node_path = require("node:path"), reactNativeWebInternals = __toESM(require("@tamagui/react-native-web-internals")), import_constants = require("../constants"), import_requireTamaguiCore = require("../helpers/requireTamaguiCore"), import_createEvaluator = require("./createEvaluator"), import_evaluateAstNode = require("./evaluateAstNode"), import_extractHelpers = require("./extractHelpers"), import_findTopmostFunction = require("./findTopmostFunction"), import_getStaticBindingsForScope = require("./getStaticBindingsForScope"), import_literalToAst = require("./literalToAst"), import_loadTamagui = require("./loadTamagui"), import_logLines = require("./logLines"), import_normalizeTernaries = require("./normalizeTernaries"), import_propsToFontFamilyCache = require("./propsToFontFamilyCache"), import_removeUnusedHooks = require("./removeUnusedHooks"), import_timer = require("./timer"), import_validHTMLAttributes = require("./validHTMLAttributes"), UNTOUCHED_PROPS = {
  key: !0,
  style: !0,
  className: !0
}, createTernary = function(x) {
  return x;
}, hasLoggedBaseInfo = !1;
function isFullyDisabled(props) {
  return props.disableExtraction && props.disableDebugAttr;
}
function createExtractor() {
  var { logger = console, platform = "web" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    logger: console
  }, INLINE_EXTRACTABLE = {
    ref: "ref",
    key: "key",
    ...platform === "web" && {
      onPress: "onClick",
      onHoverIn: "onMouseEnter",
      onHoverOut: "onMouseLeave",
      onPressIn: "onMouseDown",
      onPressOut: "onMouseUp"
    }
  }, componentState = {
    focus: !1,
    focusVisible: !1,
    focusWithin: !1,
    hover: !1,
    unmounted: !0,
    press: !1,
    pressIn: !1,
    disabled: !1
  }, styleProps = {
    resolveValues: "value",
    noClass: !1,
    isAnimated: !1
  }, shouldAddDebugProp = (
    // really basic disable this for next.js because it messes with ssr
    !process.env.npm_package_dependencies_next && !1
  ), projectInfo = null;
  function loadSync(props) {
    return isFullyDisabled(props) ? null : projectInfo || (projectInfo = (0, import_loadTamagui.loadTamaguiSync)(props));
  }
  async function load(props) {
    return isFullyDisabled(props) ? null : projectInfo || (projectInfo = await (0, import_loadTamagui.loadTamagui)(props));
  }
  return {
    options: {
      logger
    },
    cleanupBeforeExit: import_getStaticBindingsForScope.cleanupBeforeExit,
    loadTamagui: load,
    loadTamaguiSync: loadSync,
    getTamagui() {
      return projectInfo == null ? void 0 : projectInfo.tamaguiConfig;
    },
    parseSync: function(f, props) {
      var projectInfo2 = loadSync(props);
      return parseWithConfig(projectInfo2 || {}, f, props);
    },
    parse: async function(f, props) {
      var projectInfo2 = await load(props);
      return parseWithConfig(projectInfo2 || {}, f, props);
    }
  };
  function parseWithConfig(param, fileOrPath, options) {
    var { components, tamaguiConfig } = param, { config = "tamagui.config.ts", importsWhitelist = [
      "constants.js"
    ], evaluateVars = !0, sourcePath = "", onExtractTag, onStyleRule, getFlattenedNode, disable, disableExtraction, disableExtractInlineMedia, disableExtractVariables, disableDebugAttr, enableDynamicEvaluation = !1, disableOptimizeHooks, includeExtensions = [
      ".ts",
      ".tsx",
      ".jsx"
    ], extractStyledDefinitions = !1, prefixLogs, excludeProps, platform: platform2, ...restProps } = options, validHooks = disableOptimizeHooks ? {} : {
      useMedia: !0,
      useTheme: !0
    };
    if (sourcePath.includes(".tamagui-dynamic-eval"))
      return null;
    var { normalizeStyle, getSplitStyles, mediaQueryConfig, propMapper, proxyThemeVariables, pseudoDescriptors } = (0, import_requireTamaguiCore.requireTamaguiCore)(platform2), shouldPrintDebug = options.shouldPrintDebug || !1;
    if (disable === !0 || Array.isArray(disable) && disable.includes(sourcePath))
      return null;
    if (!isFullyDisabled(options) && !components)
      throw new Error("Must provide components");
    if (sourcePath && includeExtensions && !includeExtensions.some(function(ext) {
      return sourcePath.endsWith(ext);
    }))
      return shouldPrintDebug && logger.info(`Ignoring file due to includeExtensions: ${sourcePath}, includeExtensions: ${includeExtensions.join(", ")}`), null;
    function isValidStyleKey(name, staticConfig) {
      var _staticConfig_validStyles, _staticConfig_variants, _projectInfo_tamaguiConfig;
      if (!projectInfo)
        throw new Error("Tamagui extractor not loaded yet");
      return platform2 === "native" && name[0] === "$" && mediaQueryConfig[name.slice(1)] ? !1 : !!(!((_staticConfig_validStyles = staticConfig.validStyles) === null || _staticConfig_validStyles === void 0) && _staticConfig_validStyles[name] || pseudoDescriptors[name] || !((_staticConfig_variants = staticConfig.variants) === null || _staticConfig_variants === void 0) && _staticConfig_variants[name] || !(projectInfo == null || (_projectInfo_tamaguiConfig = projectInfo.tamaguiConfig) === null || _projectInfo_tamaguiConfig === void 0) && _projectInfo_tamaguiConfig.shorthands[name] || name[0] === "$" && mediaQueryConfig[name.slice(1)]);
    }
    var isTargetingHTML = platform2 === "web", ogDebug = shouldPrintDebug, tm = (0, import_timer.timer)(), propsWithFileInfo = {
      ...options,
      sourcePath,
      allLoadedComponents: components ? [
        ...components
      ] : []
    };
    if (!hasLoggedBaseInfo) {
      var _process_env_DEBUG;
      hasLoggedBaseInfo = !0, shouldPrintDebug && logger.info([
        "loaded components:",
        propsWithFileInfo.allLoadedComponents.map(function(comp2) {
          return Object.keys(comp2.nameToInfo).join(", ");
        }).join(", ")
      ].join(" ")), !((_process_env_DEBUG = process.env.DEBUG) === null || _process_env_DEBUG === void 0) && _process_env_DEBUG.startsWith("tamagui") && logger.info([
        "loaded:",
        propsWithFileInfo.allLoadedComponents.map(function(x) {
          return x.moduleName;
        })
      ].join(`
`));
    }
    tm.mark("load-tamagui", !!shouldPrintDebug), isFullyDisabled(options) || tamaguiConfig != null && tamaguiConfig.themes || (console.error(`\u26D4\uFE0F Error: Missing "themes" in your tamagui.config file:

            You may not need the compiler! Remember you can run Tamagui with no configuration at all.

            You may have not "export default" your config (you can also "export const config").
            
            Or this may be due to duplicated dependency versions:
              - try out https://github.com/bmish/check-dependency-version-consistency to see if there are mis-matches.
              - or search your lockfile for mis-matches.
          `), console.info("  Got config:", tamaguiConfig), process.exit(0));
    var firstThemeName = Object.keys((tamaguiConfig == null ? void 0 : tamaguiConfig.themes) || {})[0], firstTheme = (tamaguiConfig == null ? void 0 : tamaguiConfig.themes[firstThemeName]) || {};
    if (!firstTheme || typeof firstTheme != "object") {
      var _$err = `Missing theme ${firstThemeName}, an error occurred when importing your config`;
      throw console.info(_$err, "Got config:", tamaguiConfig), console.info("Looking for theme:", firstThemeName), new Error(_$err);
    }
    var proxiedTheme = proxyThemeVariables(firstTheme), themeAccessListeners = /* @__PURE__ */ new Set(), defaultTheme = new Proxy(proxiedTheme, {
      get(target, key) {
        return Reflect.has(target, key) && themeAccessListeners.forEach(function(cb) {
          return cb(String(key));
        }), Reflect.get(target, key);
      }
    }), body = fileOrPath.type === "Program" ? fileOrPath.get("body") : fileOrPath.program.body;
    isFullyDisabled(options) || Object.keys(components || []).length === 0 && (console.warn("Warning: Tamagui didn't find any valid components (DEBUG=tamagui for more)"), process.env.DEBUG === "tamagui" && console.info("components", Object.keys(components || []), components)), shouldPrintDebug === "verbose" && (logger.info(`allLoadedComponent modules ${propsWithFileInfo.allLoadedComponents.map(function(k) {
      return k.moduleName;
    }).join(", ")}`), logger.info(`valid import paths: ${JSON.stringify((0, import_extractHelpers.getValidComponentsPaths)(propsWithFileInfo))}`));
    var doesUseValidImport = !1, hasImportedTheme = !1, importDeclarations = [], _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _loop = function() {
        var bodyPath = _step.value;
        if (bodyPath.type !== "ImportDeclaration") return "continue";
        var node = "node" in bodyPath ? bodyPath.node : bodyPath, moduleName = node.source.value, valid = (0, import_extractHelpers.isValidImport)(propsWithFileInfo, moduleName);
        if (valid && importDeclarations.push(node), shouldPrintDebug === "verbose" && logger.info(` - import ${moduleName} ${valid}`), extractStyledDefinitions && valid && node.specifiers.some(function(specifier) {
          return specifier.local.name === "styled";
        }))
          return doesUseValidImport = !0, "break";
        if (valid) {
          var names = node.specifiers.map(function(specifier) {
            return specifier.local.name;
          }), isValidComponent = names.some(function(name) {
            return !!((0, import_extractHelpers.isValidImport)(propsWithFileInfo, moduleName, name) || validHooks[name]);
          });
          if (shouldPrintDebug === "verbose" && logger.info(` - import ${isValidComponent ? "\u2705" : "\u21E3"} - ${names.join(", ")} from '${moduleName}' - (valid: ${JSON.stringify((0, import_extractHelpers.getValidComponentsPaths)(propsWithFileInfo))})`), isValidComponent)
            return doesUseValidImport = !0, "break";
        }
      }, _iterator = body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var _ret = _loop();
        if (_ret === "break") break;
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
    if (shouldPrintDebug && logger.info(`${JSON.stringify({
      doesUseValidImport,
      hasImportedTheme
    }, null, 2)}
`), !doesUseValidImport)
      return null;
    function getValidImportedComponent(componentName) {
      var importDeclaration = importDeclarations.find(function(dec) {
        return dec.specifiers.some(function(spec) {
          return spec.local.name === componentName;
        });
      });
      return importDeclaration ? (0, import_extractHelpers.getValidImport)(propsWithFileInfo, importDeclaration.source.value, componentName) : null;
    }
    tm.mark("import-check", !!shouldPrintDebug);
    var couldntParse = !1, modifiedComponents = /* @__PURE__ */ new Set(), bindingCache = {}, callTraverse = function(a) {
      return fileOrPath.type === "File" ? (0, import_traverse.default)(fileOrPath, a) : fileOrPath.traverse(a);
    }, shouldDisableExtraction = disableExtraction === !0 || Array.isArray(disableExtraction) && disableExtraction.includes(sourcePath), programPath = null, res = {
      styled: 0,
      flattened: 0,
      optimized: 0,
      modified: 0,
      found: 0
    }, version = `${Math.random()}`;
    if (callTraverse({
      // @ts-ignore
      Program: {
        enter(path) {
          programPath = path;
        }
      },
      // styled() calls
      CallExpression(path) {
        if (!(disable || shouldDisableExtraction || extractStyledDefinitions === !1) && !(!t.isIdentifier(path.node.callee) || path.node.callee.name !== "styled")) {
          var variableName = t.isVariableDeclarator(path.parent) && t.isIdentifier(path.parent.id) ? path.parent.id.name : "unknown", parentNode = path.node.arguments[0];
          if (t.isIdentifier(parentNode)) {
            var parentName = parentNode.name, definition = path.node.arguments[1];
            if (!(!parentName || !definition || !t.isObjectExpression(definition))) {
              var Component = getValidImportedComponent(variableName);
              if (!Component) {
                if (enableDynamicEvaluation !== !0)
                  return;
                try {
                  shouldPrintDebug && logger.info(`Unknown component: ${variableName} = styled(${parentName}) attempting dynamic load: ${sourcePath}`);
                  var out = (0, import_loadTamagui.loadTamaguiSync)({
                    forceExports: !0,
                    components: [
                      sourcePath
                    ],
                    cacheKey: version
                  });
                  if (!(out != null && out.components)) {
                    shouldPrintDebug && logger.info(`Couldn't load, got ${out}`);
                    return;
                  }
                  if (propsWithFileInfo.allLoadedComponents = [
                    ...propsWithFileInfo.allLoadedComponents,
                    ...out.components
                  ], Component = out.components.flatMap(function(x) {
                    var _x_nameToInfo_variableName;
                    return (_x_nameToInfo_variableName = x.nameToInfo[variableName]) !== null && _x_nameToInfo_variableName !== void 0 ? _x_nameToInfo_variableName : [];
                  })[0], !out.cached) {
                    var _out_components, foundNames = (_out_components = out.components) === null || _out_components === void 0 ? void 0 : _out_components.map(function(x) {
                      return Object.keys(x.nameToInfo).join(", ");
                    }).join(", ").trim();
                    foundNames && (0, import_cli_color.colorLog)(import_cli_color.Color.FgYellow, `      | Tamagui found dynamic components: ${foundNames}`);
                  }
                } catch {
                  shouldPrintDebug && logger.info(`skip optimize styled(${variableName}), unable to pre-process (DEBUG=tamagui for more)`);
                }
              }
              if (!Component) {
                shouldPrintDebug && logger.info(" No component found");
                return;
              }
              var componentSkipProps = /* @__PURE__ */ new Set([
                ...Component.staticConfig.inlineWhenUnflattened || [],
                ...Component.staticConfig.inlineProps || [],
                // for now skip variants, will return to them
                "variants",
                "defaultVariants",
                // skip fontFamily its basically a "variant", important for theme use to be value always
                "fontFamily",
                "name",
                "focusStyle",
                "focusVisibleStyle",
                "focusWithinStyle",
                "disabledStyle",
                "hoverStyle",
                "pressStyle"
              ]), skipped = /* @__PURE__ */ new Set(), styles = {}, staticNamespace = (0, import_getStaticBindingsForScope.getStaticBindingsForScope)(path.scope, importsWhitelist, sourcePath, bindingCache, shouldPrintDebug), attemptEval = evaluateVars ? (0, import_createEvaluator.createEvaluator)({
                props: propsWithFileInfo,
                staticNamespace,
                sourcePath,
                shouldPrintDebug
              }) : import_evaluateAstNode.evaluateAstNode, attemptEvalSafe = (0, import_createEvaluator.createSafeEvaluator)(attemptEval), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
              try {
                for (var _iterator2 = definition.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
                  var property = _step2.value, _Component_staticConfig_variants;
                  if (!t.isObjectProperty(property) || !t.isIdentifier(property.key) || !isValidStyleKey(property.key.name, Component.staticConfig) || // TODO make pseudos and variants work
                  // skip pseudos
                  pseudoDescriptors[property.key.name] || !((_Component_staticConfig_variants = Component.staticConfig.variants) === null || _Component_staticConfig_variants === void 0) && _Component_staticConfig_variants[property.key.name] || componentSkipProps.has(property.key.name)) {
                    skipped.add(property);
                    continue;
                  }
                  var out1 = attemptEvalSafe(property.value);
                  out1 === import_constants.FAILED_EVAL ? skipped.add(property) : styles[property.key.name] = out1;
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
              var out2 = getSplitStyles(styles, Component.staticConfig, defaultTheme, "", componentState, styleProps, void 0, void 0, void 0, shouldPrintDebug), classNames = {
                ...out2.classNames
              };
              if (shouldPrintDebug && logger.info([
                `Extracted styled(${variableName})
`,
                JSON.stringify(styles, null, 2),
                `
 classNames:`,
                JSON.stringify(classNames, null, 2),
                `
  rulesToInsert:`,
                out2.rulesToInsert
              ].join(" ")), definition.properties = definition.properties.map(function(prop) {
                if (skipped.has(prop) || !t.isObjectProperty(prop) || !t.isIdentifier(prop.key))
                  return prop;
                var key2 = prop.key.name, value = classNames[key2];
                return value ? t.objectProperty(t.stringLiteral(key2), t.stringLiteral(value)) : prop;
              }), out2.rulesToInsert)
                for (var key in out2.rulesToInsert) {
                  var styleObject = out2.rulesToInsert[key];
                  onStyleRule == null || onStyleRule(styleObject[import_web.StyleObjectIdentifier], styleObject[import_web.StyleObjectRules]);
                }
              res.styled++, shouldPrintDebug && logger.info(`Extracted styled(${variableName})`);
            }
          }
        }
      },
      JSXElement(traversePath) {
        tm.mark("jsx-element", !!shouldPrintDebug);
        var node = traversePath.node.openingElement, ogAttributes = node.attributes.map(function(attr3) {
          return {
            ...attr3
          };
        }), componentName = (0, import_extractHelpers.findComponentName)(traversePath.scope), closingElement = traversePath.node.closingElement;
        if (closingElement && t.isJSXMemberExpression(closingElement == null ? void 0 : closingElement.name) || !t.isJSXIdentifier(node.name)) {
          shouldPrintDebug && logger.info(" skip non-identifier element");
          return;
        }
        var binding = traversePath.scope.getBinding(node.name.name), moduleName = "";
        if (binding && t.isImportDeclaration(binding.path.parent) && (moduleName = binding.path.parent.source.value, !(0, import_extractHelpers.isValidImport)(propsWithFileInfo, moduleName, binding.identifier.name))) {
          shouldPrintDebug && logger.info(` - Binding in component ${componentName} not valid import: "${binding.identifier.name}" isn't in ${moduleName}
`);
          return;
        }
        var component = (0, import_extractHelpers.getValidComponent)(propsWithFileInfo, moduleName, node.name.name);
        if (!component || !component.staticConfig) {
          shouldPrintDebug && logger.info(`
 - No Tamagui conf for: ${node.name.name}
`);
          return;
        }
        var originalNodeName = node.name.name;
        res.found++;
        var filePath = `./${(0, import_node_path.relative)(process.cwd(), sourcePath)}`, lineNumbers = node.loc ? node.loc.start.line + (node.loc.start.line !== node.loc.end.line ? `-${node.loc.end.line}` : "") : "", codePosition = `${filePath}:${lineNumbers}`, debugPropValue = node.attributes.filter(function(n) {
          return t.isJSXAttribute(n) && t.isJSXIdentifier(n.name) && n.name.name === "debug";
        }).map(function(n) {
          return n.value === null ? !0 : t.isStringLiteral(n.value) ? n.value.value : !1;
        })[0];
        if (debugPropValue && (shouldPrintDebug = debugPropValue), shouldPrintDebug && (logger.info(`\x1B[33m\x1B[0m ${componentName} | ${codePosition} -------------------`), logger.info([
          "\x1B[1m",
          "\x1B[32m",
          `<${originalNodeName} />`,
          disableDebugAttr ? "" : "\u{1F41B}"
        ].join(" "))), shouldAddDebugProp && !disableDebugAttr && (res.modified++, node.attributes.unshift(t.jsxAttribute(t.jsxIdentifier("data-is"), t.stringLiteral(node.name.name))), componentName && node.attributes.unshift(t.jsxAttribute(t.jsxIdentifier("data-in"), t.stringLiteral(componentName))), node.attributes.unshift(t.jsxAttribute(t.jsxIdentifier("data-at"), t.stringLiteral(`${(0, import_node_path.basename)(filePath)}:${lineNumbers}`)))), shouldDisableExtraction) {
          shouldPrintDebug === "verbose" && logger.info(` \u274C Extraction disabled: ${JSON.stringify(disableExtraction)}
`);
          return;
        }
        try {
          let evaluateAttribute2 = function(path) {
            var attribute = path.node, attr3 = {
              type: "attr",
              value: attribute
            };
            if (t.isJSXSpreadAttribute(attribute)) {
              var arg = attribute.argument, conditional = t.isConditionalExpression(arg) ? (
                // <YStack {...isSmall ? { color: 'red } : { color: 'blue }}
                [
                  arg.test,
                  arg.consequent,
                  arg.alternate
                ]
              ) : t.isLogicalExpression(arg) && arg.operator === "&&" ? (
                // <YStack {...isSmall && { color: 'red }}
                [
                  arg.left,
                  arg.right,
                  null
                ]
              ) : null;
              if (conditional) {
                var [test, alt, cons] = conditional;
                if (!test) throw new Error("no test");
                return [
                  alt,
                  cons
                ].some(function(side) {
                  return side && !isStaticObject2(side);
                }) ? (shouldPrintDebug && logger.info(`not extractable ${alt} ${cons}`), attr3) : [
                  ...createTernariesFromObjectProperties2(test, alt) || [],
                  ...cons && createTernariesFromObjectProperties2(t.unaryExpression("!", test), cons) || []
                ].map(function(ternary2) {
                  return {
                    type: "ternary",
                    value: ternary2
                  };
                });
              }
            }
            if (t.isJSXSpreadAttribute(attribute) || !attribute.name || typeof attribute.name.name != "string")
              return shouldPrintDebug && logger.info("  ! inlining, spread attr"), inlined.set(`${Math.random()}`, "spread"), attr3;
            var name2 = attribute.name.name;
            if (excludeProps != null && excludeProps.has(name2))
              return shouldPrintDebug && logger.info([
                "  excluding prop",
                name2
              ].join(" ")), null;
            if (inlineProps.has(name2))
              return inlined.set(name2, name2), shouldPrintDebug && logger.info([
                "  ! inlining, inline prop",
                name2
              ].join(" ")), attr3;
            if (UNTOUCHED_PROPS[name2])
              return attr3;
            if (INLINE_EXTRACTABLE[name2])
              return inlined.set(name2, INLINE_EXTRACTABLE[name2]), attr3;
            if (name2.startsWith("data-"))
              return attr3;
            if ((name2 === "enterStyle" || name2 === "exitStyle") && t.isJSXExpressionContainer(attribute == null ? void 0 : attribute.value))
              return shouldDeopt = !0, attr3;
            if (name2[0] === "$" && t.isJSXExpressionContainer(attribute == null ? void 0 : attribute.value)) {
              var shortname = name2.slice(1);
              if (mediaQueryConfig[shortname]) {
                if (platform2 === "native" && (shouldDeopt = !0), disableExtractInlineMedia)
                  return attr3;
                var expression = attribute.value.expression;
                if (!t.isJSXEmptyExpression(expression)) {
                  var ternaries2 = createTernariesFromObjectProperties2(t.stringLiteral(shortname), expression, {
                    inlineMediaQuery: shortname
                  });
                  if (ternaries2)
                    return ternaries2.map(function(value3) {
                      return {
                        type: "ternary",
                        value: value3
                      };
                    });
                }
              }
            }
            var [value2, valuePath] = function() {
              return t.isJSXExpressionContainer(attribute == null ? void 0 : attribute.value) ? [
                attribute.value.expression,
                path.get("value")
              ] : [
                attribute.value,
                path.get("value")
              ];
            }(), remove = function() {
              Array.isArray(valuePath) ? valuePath.map(function(p) {
                return p.remove();
              }) : valuePath.remove();
            };
            if (name2 === "ref")
              return shouldPrintDebug && logger.info([
                "  ! inlining, ref",
                name2
              ].join(" ")), inlined.set("ref", "ref"), attr3;
            if (name2 === "tag")
              return {
                type: "attr",
                value: path.node
              };
            if (disableExtractVariables === !0 && value2 && value2.type === "StringLiteral" && value2.value[0] === "$")
              return shouldPrintDebug && logger.info([
                `  ! inlining, native disable extract: ${name2} =`,
                value2.value
              ].join(" ")), inlined.set(name2, !0), attr3;
            if (name2 === "theme")
              return inlined.set("theme", attr3.value), attr3;
            var styleValue = attemptEvalSafe(value2);
            if (!variants[name2] && !isValidStyleKey(name2, staticConfig)) {
              var keys = [
                name2
              ], out = null;
              out = propMapper(name2, styleValue, propMapperStyleState), out && (Array.isArray(out) ? (out = Object.fromEntries(out), keys = Object.keys(out)) : (logger.warn("Error expected array but got", out), couldntParse = !0, shouldDeopt = !0)), out && (isTargetingHTML && (out = reactNativeWebInternals.createDOMProps(isTextView ? "span" : "div", out), delete out.className), keys = Object.keys(out));
              var didInline = !1, attributes = keys.map(function(key9) {
                var val2 = out[key9], isStyle = isValidStyleKey(key9, staticConfig);
                return isStyle ? {
                  type: "style",
                  value: {
                    [key9]: styleValue
                  },
                  name: key9,
                  attr: path.node
                } : import_validHTMLAttributes.validHTMLAttributes[key9] || key9.startsWith("aria-") || key9.startsWith("data-") || // this is debug stuff added by vite / new jsx transform
                key9 === "__source" || key9 === "__self" ? attr3 : (shouldPrintDebug && logger.info("  ! inlining, non-static " + key9), didInline = !0, inlined.set(key9, val2), val2);
              });
              return didInline ? (shouldPrintDebug && logger.info(`  bailing flattening due to attributes ${attributes.map(function(x) {
                return x.toString();
              })}`), attr3) : attributes;
            }
            if (styleValue !== import_constants.FAILED_EVAL)
              return inlineWhenUnflattened.has(name2) && (inlineWhenUnflattenedOGVals[name2] = {
                styleValue,
                attr: attr3
              }), isValidStyleKey(name2, staticConfig) ? (shouldPrintDebug && logger.info(`  style: ${name2} = ${JSON.stringify(styleValue)}`), name2 in defaultProps || hasSetOptimized || (res.optimized++, hasSetOptimized = !0), {
                type: "style",
                value: {
                  [name2]: styleValue
                },
                name: name2,
                attr: path.node
              }) : (variants[name2] && variantValues.set(name2, styleValue), inlined.set(name2, !0), attr3);
            if (t.isBinaryExpression(value2)) {
              shouldPrintDebug && logger.info(` binary expression ${name2} = ${value2}`);
              var { operator, left, right } = value2, lVal = attemptEvalSafe(left), rVal = attemptEvalSafe(right);
              if (shouldPrintDebug && logger.info(`  evalBinaryExpression lVal ${String(lVal)}, rVal ${String(rVal)}`), lVal !== import_constants.FAILED_EVAL && t.isConditionalExpression(right)) {
                var ternary = addBinaryConditional(operator, left, right);
                if (ternary) return ternary;
              }
              if (rVal !== import_constants.FAILED_EVAL && t.isConditionalExpression(left)) {
                var ternary1 = addBinaryConditional(operator, right, left);
                if (ternary1) return ternary1;
              }
              return shouldPrintDebug && logger.info("  evalBinaryExpression cant extract"), inlined.set(name2, !0), attr3;
            }
            var staticConditional = getStaticConditional(value2);
            if (staticConditional)
              return shouldPrintDebug === "verbose" && logger.info(` static conditional ${name2} ${value2}`), {
                type: "ternary",
                value: staticConditional
              };
            var staticLogical = getStaticLogical(value2);
            if (staticLogical)
              return shouldPrintDebug === "verbose" && logger.info(` static ternary ${name2} =  ${value2}`), {
                type: "ternary",
                value: staticLogical
              };
            if (options.experimentalFlattenDynamicValues && isValidStyleKey(name2, staticConfig))
              return {
                type: "dynamic-style",
                value: value2,
                name: (tamaguiConfig == null ? void 0 : tamaguiConfig.shorthands[name2]) || name2
              };
            return inlined.set(name2, !0), shouldPrintDebug && logger.info(` ! inline no match ${name2} ${value2}`), attr3;
            function addBinaryConditional(operator2, staticExpr, cond) {
              if (getStaticConditional(cond)) {
                var alt2 = attemptEval(t.binaryExpression(operator2, staticExpr, cond.alternate)), cons2 = attemptEval(t.binaryExpression(operator2, staticExpr, cond.consequent));
                return shouldPrintDebug && logger.info([
                  "  binaryConditional",
                  cond.test,
                  cons2,
                  alt2
                ].join(" ")), {
                  type: "ternary",
                  value: {
                    test: cond.test,
                    remove,
                    alternate: {
                      [name2]: alt2
                    },
                    consequent: {
                      [name2]: cons2
                    }
                  }
                };
              }
              return null;
            }
            function getStaticConditional(value3) {
              if (t.isConditionalExpression(value3))
                try {
                  var aVal = attemptEval(value3.alternate), cVal = attemptEval(value3.consequent);
                  if (shouldPrintDebug) {
                    var type = value3.test.type;
                    logger.info([
                      "      static ternary",
                      type,
                      cVal,
                      aVal
                    ].join(" "));
                  }
                  return {
                    test: value3.test,
                    remove,
                    consequent: {
                      [name2]: cVal
                    },
                    alternate: {
                      [name2]: aVal
                    }
                  };
                } catch (err) {
                  shouldPrintDebug && logger.info([
                    "       cant eval ternary",
                    err.message
                  ].join(" "));
                }
              return null;
            }
            function getStaticLogical(value3) {
              if (t.isLogicalExpression(value3) && value3.operator === "&&")
                try {
                  var val2 = attemptEval(value3.right);
                  return shouldPrintDebug && logger.info([
                    "  staticLogical",
                    value3.left,
                    name2,
                    val2
                  ].join(" ")), {
                    test: value3.left,
                    remove,
                    consequent: {
                      [name2]: val2
                    },
                    alternate: null
                  };
                } catch (err) {
                  shouldPrintDebug && logger.info([
                    "  cant static eval logical",
                    err
                  ].join(" "));
                }
              return null;
            }
          }, isStaticObject2 = function(obj) {
            return t.isObjectExpression(obj) && obj.properties.every(function(prop) {
              if (!t.isObjectProperty(prop))
                return logger.info([
                  "not object prop",
                  prop
                ].join(" ")), !1;
              var propName = prop.key.name;
              return !isValidStyleKey(propName, staticConfig) && propName !== "tag" ? (shouldPrintDebug && logger.info([
                "  not a valid style prop!",
                propName
              ].join(" ")), !1) : !0;
            });
          }, createTernariesFromObjectProperties2 = function(test, side) {
            var ternaryPartial = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (!side)
              return null;
            if (!isStaticObject2(side))
              throw new Error("not extractable");
            return side.properties.flatMap(function(property) {
              if (!t.isObjectProperty(property))
                throw new Error("expected object property");
              if (t.isIdentifier(property.key)) {
                var key9 = property.key.name, mediaQueryKey = key9.slice(1), isMediaQuery = key9[0] === "$" && mediaQueryConfig[mediaQueryKey];
                if (isMediaQuery)
                  if (t.isExpression(property.value)) {
                    var ternaries2 = createTernariesFromObjectProperties2(t.stringLiteral(mediaQueryKey), property.value, {
                      inlineMediaQuery: mediaQueryKey
                    });
                    if (ternaries2)
                      return ternaries2.map(function(value2) {
                        return {
                          ...ternaryPartial,
                          ...value2,
                          // ensure media query test stays on left side (see getMediaQueryTernary)
                          test: t.logicalExpression("&&", value2.test, test)
                        };
                      });
                    logger.info([
                      "\u26A0\uFE0F no ternaries?",
                      property
                    ].join(" "));
                  } else
                    logger.info([
                      "\u26A0\uFE0F not expression",
                      property
                    ].join(" "));
              }
              if (t.isConditionalExpression(property.value)) {
                var [truthy, falsy] = [
                  t.objectExpression([
                    t.objectProperty(property.key, property.value.consequent)
                  ]),
                  t.objectExpression([
                    t.objectProperty(property.key, property.value.alternate)
                  ])
                ].map(function(x) {
                  return attemptEval(x);
                });
                return [
                  createTernary({
                    remove() {
                    },
                    ...ternaryPartial,
                    test: t.logicalExpression("&&", test, property.value.test),
                    consequent: truthy,
                    alternate: null
                  }),
                  createTernary({
                    ...ternaryPartial,
                    test: t.logicalExpression("&&", test, t.unaryExpression("!", property.value.test)),
                    consequent: falsy,
                    alternate: null,
                    remove() {
                    }
                  })
                ];
              }
              var obj = t.objectExpression([
                t.objectProperty(property.key, property.value)
              ]), consequent = attemptEval(obj);
              return createTernary({
                remove() {
                },
                ...ternaryPartial,
                test,
                consequent,
                alternate: null
              });
            });
          }, mergeToEnd2 = function(obj, key9, val2) {
            key9 in obj && delete obj[key9], obj[key9] = val2;
          }, normalizeStyleWithoutVariants2 = function(style) {
            var res2 = {};
            for (var key9 in style)
              if (staticConfig.variants && key9 in staticConfig.variants)
                mergeToEnd2(res2, key9, style[key9]);
              else {
                var expanded2 = normalizeStyle({
                  [key9]: style[key9]
                }, !0);
                for (var key12 in expanded2)
                  mergeToEnd2(res2, key12, expanded2[key12]);
              }
            return res2;
          }, mergeStyles2 = function(prev2, next) {
            for (var key9 in next)
              pseudoDescriptors[key9] ? (prev2[key9] = prev2[key9] || {}, Object.assign(prev2[key9], next[key9])) : mergeToEnd2(prev2, key9, next[key9]);
          };
          var evaluateAttribute = evaluateAttribute2, isStaticObject = isStaticObject2, createTernariesFromObjectProperties = createTernariesFromObjectProperties2, mergeToEnd = mergeToEnd2, normalizeStyleWithoutVariants = normalizeStyleWithoutVariants2, mergeStyles = mergeStyles2, { staticConfig } = component, defaultProps = {
            ...staticConfig.defaultProps || {}
          }, variants = staticConfig.variants || {}, isTextView = staticConfig.isText || !1, _staticConfig_validStyles, validStyles = (_staticConfig_validStyles = staticConfig == null ? void 0 : staticConfig.validStyles) !== null && _staticConfig_validStyles !== void 0 ? _staticConfig_validStyles : {}, _defaultProps_tag, tagName = (_defaultProps_tag = defaultProps.tag) !== null && _defaultProps_tag !== void 0 ? _defaultProps_tag : isTextView ? "span" : "div";
          traversePath.get("openingElement").get("attributes").forEach(function(path) {
            var attr3 = path.node;
            if (!t.isJSXSpreadAttribute(attr3) && attr3.name.name === "tag") {
              var val2 = attr3.value;
              t.isStringLiteral(val2) && (tagName = val2.value);
            }
          }), shouldPrintDebug === "verbose" && console.info(` Start tag ${tagName}`);
          var flatNode = getFlattenedNode == null ? void 0 : getFlattenedNode({
            isTextView,
            tag: tagName
          }), inlineProps = /* @__PURE__ */ new Set([
            // adding some always inline props
            "dataSet",
            ...restProps.inlineProps || [],
            ...staticConfig.inlineProps || []
          ]), deoptProps = /* @__PURE__ */ new Set([
            // always de-opt animation these
            "animation",
            "animateOnly",
            "animatePresence",
            "disableOptimization",
            ...isTargetingHTML ? [] : [
              "pressStyle",
              "focusStyle",
              "focusVisibleStyle",
              "focusWithinStyle",
              "disabledStyle"
            ],
            // when using a non-CSS driver, de-opt on enterStyle/exitStyle
            ...tamaguiConfig != null && tamaguiConfig.animations.isReactNative ? [
              "enterStyle",
              "exitStyle"
            ] : []
          ]), inlineWhenUnflattened = /* @__PURE__ */ new Set([
            ...staticConfig.inlineWhenUnflattened || []
          ]), staticNamespace = (0, import_getStaticBindingsForScope.getStaticBindingsForScope)(traversePath.scope, importsWhitelist, sourcePath, bindingCache, shouldPrintDebug), attemptEval = evaluateVars ? (0, import_createEvaluator.createEvaluator)({
            props: propsWithFileInfo,
            staticNamespace,
            sourcePath,
            traversePath,
            shouldPrintDebug
          }) : import_evaluateAstNode.evaluateAstNode, attemptEvalSafe = (0, import_createEvaluator.createSafeEvaluator)(attemptEval);
          if (shouldPrintDebug && logger.info(`  staticNamespace ${Object.keys(staticNamespace).join(", ")}`), couldntParse)
            return;
          tm.mark("jsx-element-flattened", !!shouldPrintDebug);
          var attrs = [], shouldDeopt = !1, inlined = /* @__PURE__ */ new Map(), variantValues = /* @__PURE__ */ new Map(), hasSetOptimized = !1, inlineWhenUnflattenedOGVals = {}, propMapperStyleState = {
            staticConfig,
            usedKeys: {},
            classNames: {},
            style: {},
            theme: defaultTheme,
            viewProps: defaultProps,
            conf: tamaguiConfig,
            props: defaultProps,
            componentState,
            styleProps: {
              ...styleProps,
              resolveValues: "auto"
            },
            debug: shouldPrintDebug
          };
          if (attrs = traversePath.get("openingElement").get("attributes").flatMap(function(path) {
            try {
              var res2 = evaluateAttribute2(path);
              return res2 || path.remove(), res2;
            } catch (err) {
              if (shouldPrintDebug && (logger.info([
                "Recoverable error extracting attribute",
                err.message,
                shouldPrintDebug === "verbose" ? err.stack : ""
              ].join(" ")), shouldPrintDebug === "verbose")) {
                var _path_node;
                logger.info(`node ${(_path_node = path.node) === null || _path_node === void 0 ? void 0 : _path_node.type}`);
              }
              return inlined.set(`${Math.random()}`, "spread"), {
                type: "attr",
                value: path.node
              };
            }
          }).flat(4).filter(import_extractHelpers.isPresent), shouldPrintDebug && logger.info([
            `  - attrs (before):
`,
            (0, import_logLines.logLines)(attrs.map(import_extractHelpers.attrStr).join(", "))
          ].join(" ")), couldntParse || shouldDeopt) {
            shouldPrintDebug && logger.info([
              "  avoid optimizing:",
              {
                couldntParse,
                shouldDeopt
              }
            ].join(" ")), node.attributes = ogAttributes;
            return;
          }
          var parentFn = (0, import_findTopmostFunction.findTopmostFunction)(traversePath);
          parentFn && modifiedComponents.add(parentFn);
          var hasSpread = attrs.some(function(x) {
            return x.type === "attr" && t.isJSXSpreadAttribute(x.value);
          }), hasOnlyStringChildren = !hasSpread && (node.selfClosing || traversePath.node.children && traversePath.node.children.every(function(x) {
            return x.type === "JSXText";
          })), themeVal = inlined.get("theme");
          platform2 !== "native" && inlined.delete("theme");
          for (var _i = 0, _iter = [
            ...inlined
          ]; _i < _iter.length; _i++) {
            var [key] = _iter[_i], _staticConfig_variants, isStaticObjectVariant = ((_staticConfig_variants = staticConfig.variants) === null || _staticConfig_variants === void 0 ? void 0 : _staticConfig_variants[key]) && variantValues.has(key);
            (INLINE_EXTRACTABLE[key] || isStaticObjectVariant) && inlined.delete(key);
          }
          var canFlattenProps = inlined.size === 0, shouldFlatten = !!(flatNode && !shouldDeopt && canFlattenProps && !hasSpread && !staticConfig.isStyledHOC && !staticConfig.isHOC && !staticConfig.isReactNative && staticConfig.neverFlatten !== !0 && (staticConfig.neverFlatten !== "jsx" || hasOnlyStringChildren)), usedThemeKeys = /* @__PURE__ */ new Set();
          if (themeAccessListeners.add(function(key9) {
            disableExtractVariables && (usedThemeKeys.add(key9), shouldFlatten = !1, shouldPrintDebug === "verbose" && logger.info([
              " ! accessing theme key, avoid flatten",
              key9
            ].join(" ")));
          }), shouldFlatten) {
            var skipMap = !1, defaultStyleAttrs = Object.keys(defaultProps).flatMap(function(key9) {
              if (skipMap) return [];
              var value2 = defaultProps[key9];
              if (key9 === "theme" && !themeVal)
                return platform2 === "native" && (shouldFlatten = !1, skipMap = !0, inlined.set("theme", {
                  value: t.stringLiteral(value2)
                })), themeVal = {
                  value: t.stringLiteral(value2)
                }, [];
              if (!isValidStyleKey(key9, staticConfig))
                return [];
              var name2 = (tamaguiConfig == null ? void 0 : tamaguiConfig.shorthands[key9]) || key9;
              if (value2 === void 0) {
                logger.warn(`\u26A0\uFE0F Error evaluating default style for component, prop ${key9} ${value2}`), shouldDeopt = !0;
                return;
              }
              if (name2[0] === "$" && mediaQueryConfig[name2.slice(1)])
                return defaultProps[key9] = void 0, evaluateAttribute2({
                  node: t.jsxAttribute(t.jsxIdentifier(name2), t.jsxExpressionContainer(t.objectExpression(Object.keys(value2).filter(function(k) {
                    return typeof value2[k] < "u";
                  }).map(function(k) {
                    return t.objectProperty(t.identifier(k), (0, import_literalToAst.literalToAst)(value2[k]));
                  }))))
                });
              var attr3 = {
                type: "style",
                name: name2,
                value: {
                  [name2]: value2
                }
              };
              return attr3;
            });
            skipMap || defaultStyleAttrs.length && (attrs = [
              ...defaultStyleAttrs,
              ...attrs
            ]);
          }
          var ternaries = [];
          attrs = attrs.reduce(function(out, cur2) {
            var next = attrs[attrs.indexOf(cur2) + 1];
            if (cur2.type === "ternary" && ternaries.push(cur2.value), (!next || next.type !== "ternary") && ternaries.length) {
              var normalized = (0, import_normalizeTernaries.normalizeTernaries)(ternaries).map(function(param2) {
                var { alternate, consequent, ...rest } = param2;
                return {
                  type: "ternary",
                  value: {
                    ...rest,
                    alternate: alternate || null,
                    consequent: consequent || null
                  }
                };
              });
              try {
                return [
                  ...out,
                  ...normalized
                ];
              } finally {
                shouldPrintDebug && logger.info(`    normalizeTernaries (${ternaries.length} => ${normalized.length})`), ternaries = [];
              }
            }
            return cur2.type === "ternary" || out.push(cur2), out;
          }, []).flat();
          var shouldWrapTheme = shouldFlatten && themeVal;
          if (shouldWrapTheme && (programPath ? (shouldPrintDebug && logger.info([
            "  - wrapping theme",
            themeVal
          ].join(" ")), attrs = attrs.filter(function(x) {
            return !(x.type === "attr" && t.isJSXAttribute(x.value) && x.value.name.name === "theme");
          }), hasImportedTheme || (hasImportedTheme = !0, programPath.node.body.push(t.importDeclaration([
            t.importSpecifier(t.identifier("_TamaguiTheme"), t.identifier("Theme"))
          ], t.stringLiteral("@tamagui/web")))), traversePath.replaceWith(t.jsxElement(t.jsxOpeningElement(t.jsxIdentifier("_TamaguiTheme"), [
            t.jsxAttribute(t.jsxIdentifier("name"), themeVal.value)
          ]), t.jsxClosingElement(t.jsxIdentifier("_TamaguiTheme")), [
            traversePath.node
          ]))) : console.warn(`No program path found, avoiding importing flattening / importing theme in ${sourcePath}`)), shouldPrintDebug)
            try {
              logger.info([
                " flatten?",
                shouldFlatten,
                (0, import_extractHelpers.objToStr)({
                  hasSpread,
                  shouldDeopt,
                  canFlattenProps,
                  shouldWrapTheme,
                  hasOnlyStringChildren
                }),
                "inlined",
                inlined.size,
                [
                  ...inlined
                ]
              ].join(" "));
            } catch {
            }
          if (shouldDeopt || !shouldFlatten) {
            shouldPrintDebug && logger.info(`Deopting ${shouldDeopt} ${shouldFlatten}`), node.attributes = ogAttributes;
            return;
          }
          shouldPrintDebug && logger.info([
            `  - attrs (flattened): 
`,
            (0, import_logLines.logLines)(attrs.map(import_extractHelpers.attrStr).join(", "))
          ].join(" "));
          var foundStaticProps = {};
          for (var key1 in attrs) {
            var cur = attrs[key1];
            if (cur.type === "style") {
              var expanded = normalizeStyleWithoutVariants2(cur.value);
              for (var key2 in expanded)
                mergeToEnd2(foundStaticProps, key2, expanded[key2]);
              continue;
            }
            if (cur.type === "attr") {
              if (t.isJSXSpreadAttribute(cur.value) || !t.isJSXIdentifier(cur.value.name))
                continue;
              var key3 = cur.value.name.name, value = attemptEvalSafe(cur.value.value || t.booleanLiteral(!0));
              value !== import_constants.FAILED_EVAL && mergeToEnd2(foundStaticProps, key3, value);
            }
          }
          var completeProps = {};
          for (var key4 in defaultProps)
            key4 in foundStaticProps || (completeProps[key4] = defaultProps[key4]);
          for (var key5 in foundStaticProps)
            completeProps[key5] = foundStaticProps[key5];
          attrs = attrs.reduce(function(acc, cur2) {
            if (!cur2) return acc;
            if (cur2.type === "attr" && !t.isJSXSpreadAttribute(cur2.value) && shouldFlatten) {
              var name2 = cur2.value.name.name;
              if (typeof name2 == "string") {
                if (name2 === "tag")
                  return acc;
                if (variants[name2] && variantValues.has(name2)) {
                  var styleState = {
                    ...propMapperStyleState,
                    props: completeProps
                  }, out = Object.fromEntries(propMapper(name2, variantValues.get(name2), styleState) || []);
                  if (out && isTargetingHTML) {
                    var cn = out.className;
                    out = reactNativeWebInternals.createDOMProps(isTextView ? "span" : "div", out), out.className = cn;
                  }
                  shouldPrintDebug && logger.info([
                    " - expanded variant",
                    name2,
                    out
                  ].join(" "));
                  for (var key9 in out) {
                    var value2 = out[key9];
                    isValidStyleKey(key9, staticConfig) ? acc.push({
                      type: "style",
                      value: {
                        [key9]: value2
                      },
                      name: key9,
                      attr: cur2.value
                    }) : acc.push({
                      type: "attr",
                      value: t.jsxAttribute(t.jsxIdentifier(key9), t.jsxExpressionContainer(typeof value2 == "string" ? t.stringLiteral(value2) : (0, import_literalToAst.literalToAst)(value2)))
                    });
                  }
                }
              }
            }
            if (cur2.type !== "style")
              return acc.push(cur2), acc;
            var key12 = Object.keys(cur2.value)[0], value12 = cur2.value[key12], fullKey = tamaguiConfig == null ? void 0 : tamaguiConfig.shorthands[key12];
            return fullKey && (cur2.value = {
              [fullKey]: value12
            }, key12 = fullKey), disableExtractVariables && value12[0] === "$" && (usedThemeKeys.has(key12) || usedThemeKeys.has(fullKey)) ? (shouldPrintDebug && logger.info([
              `   keeping variable inline: ${key12} =`,
              value12
            ].join(" ")), acc.push({
              type: "attr",
              value: t.jsxAttribute(t.jsxIdentifier(key12), t.jsxExpressionContainer(t.stringLiteral(value12)))
            }), acc) : (acc.push(cur2), acc);
          }, []), tm.mark("jsx-element-expanded", !!shouldPrintDebug), shouldPrintDebug && logger.info([
            `  - attrs (expanded): 
`,
            (0, import_logLines.logLines)(attrs.map(import_extractHelpers.attrStr).join(", "))
          ].join(" "));
          var prev = null, getProps = function(props) {
            var includeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, debugName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
            if (!props)
              return shouldPrintDebug && logger.info([
                " getProps() no props"
              ].join(" ")), {};
            if (excludeProps != null && excludeProps.size)
              for (var key9 in props)
                excludeProps.has(key9) && (shouldPrintDebug && logger.info([
                  " delete excluded",
                  key9
                ].join(" ")), delete props[key9]);
            var before = process.env.IS_STATIC;
            process.env.IS_STATIC = "is_static";
            try {
              var out = getSplitStyles(props, staticConfig, defaultTheme, "", componentState, {
                ...styleProps,
                noClass: !0,
                fallbackProps: completeProps
              }, void 0, void 0, void 0, debugPropValue || shouldPrintDebug), outProps2 = {
                ...includeProps ? out.viewProps : {},
                ...out.style,
                ...out.pseudos
              };
              for (var key12 in outProps2)
                deoptProps.has(key12) && (shouldFlatten = !1);
              return shouldPrintDebug && (logger.info(`(${debugName})`), logger.info(`
       getProps (props in): ${(0, import_logLines.logLines)((0, import_extractHelpers.objToStr)(props))}`), logger.info(`
       getProps (outProps): ${(0, import_logLines.logLines)((0, import_extractHelpers.objToStr)(outProps2))}`)), out.fontFamily && ((0, import_propsToFontFamilyCache.setPropsToFontFamily)(outProps2, out.fontFamily), shouldPrintDebug && logger.info(`
      \u{1F4AC} new font fam: ${out.fontFamily}`)), outProps2;
            } catch (err) {
              return logger.info([
                "error",
                err.message,
                err.stack
              ].join(" ")), {};
            } finally {
              process.env.IS_STATIC = before;
            }
          };
          shouldFlatten && attrs.unshift({
            type: "style",
            value: defaultProps
          }), attrs = attrs.reduce(function(acc, cur2) {
            if (cur2.type === "style") {
              var key9 = Object.keys(cur2.value)[0], value2 = cur2.value[key9], shouldKeepOriginalAttr = (
                // !isStyleAndAttr[key] &&
                !shouldFlatten && // de-opt if non-style
                !validStyles[key9] && !pseudoDescriptors[key9] && !(key9.startsWith("data-") || key9.startsWith("aria-"))
              );
              if (shouldKeepOriginalAttr)
                return shouldPrintDebug && logger.info([
                  "     - keeping as non-style",
                  key9
                ].join(" ")), prev = cur2, acc.push({
                  type: "attr",
                  value: t.jsxAttribute(t.jsxIdentifier(key9), t.jsxExpressionContainer(typeof value2 == "string" ? t.stringLiteral(value2) : (0, import_literalToAst.literalToAst)(value2)))
                }), acc.push(cur2), acc;
              if ((prev == null ? void 0 : prev.type) === "style")
                return mergeStyles2(prev.value, cur2.value), acc;
            }
            return cur2.type === "style" && (prev = cur2), acc.push(cur2), acc;
          }, []), shouldPrintDebug && logger.info([
            `  - attrs (combined \u{1F500}): 
`,
            (0, import_logLines.logLines)(attrs.map(import_extractHelpers.attrStr).join(", "))
          ].join(" "));
          var getStyleError = null, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator2 = attrs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
              var attr = _step2.value;
              try {
                switch (shouldPrintDebug && console.info(`  Processing ${attr.type}:`), attr.type) {
                  case "ternary": {
                    var a = getProps(attr.value.alternate, !1, "ternary.alternate"), c = getProps(attr.value.consequent, !1, "ternary.consequent");
                    a && (attr.value.alternate = a), c && (attr.value.consequent = c), shouldPrintDebug && logger.info([
                      "     => tern ",
                      (0, import_extractHelpers.attrStr)(attr)
                    ].join(" "));
                    continue;
                  }
                  case "style": {
                    var styles = getProps(attr.value, !1, "style");
                    styles && (attr.value = styles), shouldPrintDebug && logger.info([
                      "  * styles (in)",
                      (0, import_logLines.logLines)((0, import_extractHelpers.objToStr)(attr.value))
                    ].join(" ")), shouldPrintDebug && logger.info([
                      "  * styles (out)",
                      (0, import_logLines.logLines)((0, import_extractHelpers.objToStr)(styles))
                    ].join(" "));
                    continue;
                  }
                  case "attr":
                    if (shouldFlatten && t.isJSXAttribute(attr.value)) {
                      var key6 = attr.value.name.name;
                      if (key6 === "style" || key6 === "className" || key6 === "tag")
                        continue;
                      var value1 = attemptEvalSafe(attr.value.value || t.booleanLiteral(!0));
                      if (value1 !== import_constants.FAILED_EVAL) {
                        var outProps = getProps({
                          [key6]: value1
                        }, !0, `attr.${key6}`), outKey = Object.keys(outProps)[0];
                        if (outKey) {
                          var outVal = outProps[outKey];
                          attr.value = t.jsxAttribute(t.jsxIdentifier(outKey), t.jsxExpressionContainer(typeof outVal == "string" ? t.stringLiteral(outVal) : (0, import_literalToAst.literalToAst)(outVal)));
                        }
                      }
                    }
                }
              } catch (err) {
                getStyleError = err;
              }
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
          if (shouldPrintDebug && logger.info([
            `  - attrs (ternaries/combined):
`,
            (0, import_logLines.logLines)(attrs.map(import_extractHelpers.attrStr).join(", "))
          ].join(" ")), tm.mark("jsx-element-styles", !!shouldPrintDebug), getStyleError)
            return logger.info([
              " \u26A0\uFE0F postprocessing error, deopt",
              getStyleError
            ].join(" ")), node.attributes = ogAttributes, null;
          for (var existingStyleKeys = /* @__PURE__ */ new Set(), i = attrs.length - 1; i >= 0; i--) {
            var attr1 = attrs[i];
            if (shouldFlatten && attr1.type === "attr" && t.isJSXAttribute(attr1.value) && t.isJSXIdentifier(attr1.value.name)) {
              var name = attr1.value.name.name;
              INLINE_EXTRACTABLE[name] && (attr1.value.name.name = INLINE_EXTRACTABLE[name]);
            }
            if (attr1.type === "style")
              for (var key7 in attr1.value)
                existingStyleKeys.has(key7) ? (shouldPrintDebug && logger.info([
                  `  >> delete existing ${key7}`
                ].join(" ")), delete attr1.value[key7]) : existingStyleKeys.add(key7);
            attr1.type === "dynamic-style" && (existingStyleKeys.has(attr1.name) ? attrs[i] = void 0 : existingStyleKeys.add(attr1.name));
          }
          if (options.experimentalFlattenThemesOnNative && (attrs = attrs.filter(Boolean)), !shouldFlatten && inlineWhenUnflattened.size) {
            var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = attrs.entries()[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = !0) {
                var [index, attr2] = _step12.value;
                if (attr2.type === "style") {
                  for (var key8 in attr2.value)
                    if (inlineWhenUnflattened.has(key8)) {
                      var val = inlineWhenUnflattenedOGVals[key8];
                      val ? (delete attr2.value[key8], attrs.splice(index - 1, 0, val.attr)) : delete attr2.value[key8];
                    }
                }
              }
            } catch (err) {
              _didIteratorError12 = !0, _iteratorError12 = err;
            } finally {
              try {
                !_iteratorNormalCompletion12 && _iterator12.return != null && _iterator12.return();
              } finally {
                if (_didIteratorError12)
                  throw _iteratorError12;
              }
            }
          }
          attrs = attrs.filter(function(x) {
            return !((x.type === "style" || x.type === "dynamic-style") && Object.keys(x.value).length === 0);
          }), shouldFlatten && (shouldPrintDebug && logger.info([
            "  [\u2705] flattening",
            originalNodeName,
            flatNode
          ].join(" ")), node.name.name = flatNode, res.flattened++, closingElement && (closingElement.name.name = flatNode));
          var isNativeNotFlat = !shouldFlatten && platform2 === "native";
          if (isNativeNotFlat)
            return shouldPrintDebug && logger.info(`Disabled flattening except for simple cases on native for now: ${JSON.stringify({
              flatNode,
              shouldDeopt,
              canFlattenProps,
              hasSpread,
              "staticConfig.isStyledHOC": staticConfig.isStyledHOC,
              "!staticConfig.isHOC": !staticConfig.isHOC,
              "staticConfig.isReactNative": staticConfig.isReactNative,
              "staticConfig.neverFlatten": staticConfig.neverFlatten
            }, null, 2)}`), node.attributes = ogAttributes, null;
          shouldPrintDebug && (logger.info([
            ` - inlined props (${inlined.size}):`,
            shouldDeopt ? " deopted" : "",
            hasSpread ? " has spread" : "",
            staticConfig.neverFlatten ? "neverFlatten" : ""
          ].join(" ")), logger.info(`  - shouldFlatten/isFlattened: ${shouldFlatten}`), logger.info(`  - attrs (end):
 ${(0, import_logLines.logLines)(attrs.map(import_extractHelpers.attrStr).join(", "))}`)), onExtractTag({
            parserProps: propsWithFileInfo,
            attrs,
            node,
            lineNumbers,
            filePath,
            config: tamaguiConfig,
            attemptEval,
            jsxPath: traversePath,
            originalNodeName,
            isFlattened: shouldFlatten,
            programPath,
            completeProps,
            staticConfig
          });
        } catch (err) {
          node.attributes = ogAttributes, console.error(`@tamagui/static error, reverting optimization. In ${filePath} ${lineNumbers} on ${originalNodeName}: ${err.message}. For stack trace set environment TAMAGUI_DEBUG=1`), process.env.TAMAGUI_DEBUG === "1" && console.error(err.stack);
        } finally {
          debugPropValue && (shouldPrintDebug = ogDebug);
        }
      }
    }), tm.mark("jsx-done", !!shouldPrintDebug), modifiedComponents.size) {
      var all = Array.from(modifiedComponents);
      shouldPrintDebug && logger.info(`  [\u{1FA9D}] hook check ${all.length}`);
      var _iteratorNormalCompletion1 = !0, _didIteratorError1 = !1, _iteratorError1 = void 0;
      try {
        for (var _iterator1 = all[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0) {
          var comp = _step1.value;
          (0, import_removeUnusedHooks.removeUnusedHooks)(comp, shouldPrintDebug);
        }
      } catch (err) {
        _didIteratorError1 = !0, _iteratorError1 = err;
      } finally {
        try {
          !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
        } finally {
          if (_didIteratorError1)
            throw _iteratorError1;
        }
      }
    }
    return tm.done(shouldPrintDebug === "verbose"), res;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createExtractor
});
//# sourceMappingURL=createExtractor.js.map
