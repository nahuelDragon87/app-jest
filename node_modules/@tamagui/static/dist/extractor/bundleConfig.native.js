"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var bundleConfig_exports = {};
__export(bundleConfig_exports, {
  bundleConfig: () => bundleConfig,
  esbuildOptions: () => esbuildOptions,
  getBundledConfig: () => getBundledConfig,
  getLoadedConfig: () => getLoadedConfig,
  hasBundledConfigChanged: () => hasBundledConfigChanged,
  loadComponents: () => loadComponents,
  loadComponentsInner: () => loadComponentsInner,
  writeTamaguiCSS: () => writeTamaguiCSS
});
module.exports = __toCommonJS(bundleConfig_exports);
var import_generator = __toESM(require("@babel/generator")), import_traverse = __toESM(require("@babel/traverse")), t = __toESM(require("@babel/types")), import_node_fs = require("node:fs"), import_node_path = require("node:path"), import_cli_color = require("@tamagui/cli-color"), import_esbuild = __toESM(require("esbuild")), FS = __toESM(require("fs-extra")), import_promises = require("node:fs/promises"), import_registerRequire = require("../registerRequire"), import_babelParse = require("./babelParse"), import_bundle = require("./bundle"), import_getTamaguiConfigPathFromOptionsConfig = require("./getTamaguiConfigPathFromOptionsConfig"), _global, external = [
  "@tamagui/core",
  "@tamagui/web",
  "react",
  "react-dom",
  "react-native-svg"
], esbuildExtraOptions = {
  define: {
    __DEV__: `${process.env.NODE_ENV === "development"}`
  }
}, esbuildOptions = {
  target: "es2018",
  format: "cjs",
  jsx: "automatic",
  platform: "node",
  ...esbuildExtraOptions
}, currentBundle = null, isBundling = !1, lastBundle = null, waitForBundle = /* @__PURE__ */ new Set();
function hasBundledConfigChanged() {
  return lastBundle === currentBundle ? !1 : (lastBundle = currentBundle, !0);
}
var loadedConfig = null, getLoadedConfig = function() {
  return loadedConfig;
};
async function getBundledConfig(props) {
  var rebuild = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (isBundling)
    await new Promise(function(res) {
      waitForBundle.add(res);
    });
  else if (!currentBundle || rebuild)
    return await bundleConfig(props);
  return currentBundle;
}
(_global = global).tamaguiLastLoaded || (_global.tamaguiLastLoaded = 0);
function updateLastLoaded(config) {
  global.tamaguiLastLoaded = Date.now(), global.tamaguiLastBundledConfig = config;
}
var hasBundledOnce = !1;
async function bundleConfig(props) {
  if (global.tamaguiLastBundledConfig && Date.now() - global.tamaguiLastLoaded < 3e3)
    return global.tamaguiLastBundledConfig;
  try {
    var _process_env_DEBUG, _process_env_DEBUG1;
    isBundling = !0;
    var configEntry = props.config ? (0, import_getTamaguiConfigPathFromOptionsConfig.getTamaguiConfigPathFromOptionsConfig)(props.config) : "", tmpDir = (0, import_node_path.join)(process.cwd(), ".tamagui"), configOutPath = (0, import_node_path.join)(tmpDir, "tamagui.config.cjs"), baseComponents = (props.components || []).filter(function(x) {
      return x !== "@tamagui/core";
    }), componentOutPaths = baseComponents.map(function(componentModule) {
      return (0, import_node_path.join)(tmpDir, `${componentModule.split(import_node_path.sep).join("-").replace(/[^a-z0-9]+/gi, "")}-components.config.cjs`);
    });
    if (process.env.NODE_ENV === "development" && (!((_process_env_DEBUG = process.env.DEBUG) === null || _process_env_DEBUG === void 0) && _process_env_DEBUG.startsWith("tamagui")) && console.info("Building config entry", configEntry), !props.disableInitialBuild) {
      var _process_env_DEBUG2;
      try {
        await FS.ensureDir(tmpDir);
      } catch {
      }
      var start = Date.now();
      await Promise.all([
        props.config ? (0, import_bundle.esbundleTamaguiConfig)({
          entryPoints: [
            configEntry
          ],
          external,
          outfile: configOutPath,
          target: "node20",
          ...esbuildExtraOptions
        }, props.platform || "web") : null,
        ...baseComponents.map(function(componentModule, i) {
          return (0, import_bundle.esbundleTamaguiConfig)({
            entryPoints: [
              componentModule
            ],
            resolvePlatformSpecificEntries: !0,
            external,
            outfile: componentOutPaths[i],
            target: "node20",
            ...esbuildExtraOptions
          }, props.platform || "web");
        })
      ]), (0, import_cli_color.colorLog)(import_cli_color.Color.FgYellow, `
    \u27A1 [tamagui] built config and components (${Date.now() - start}ms)`), !((_process_env_DEBUG2 = process.env.DEBUG) === null || _process_env_DEBUG2 === void 0) && _process_env_DEBUG2.startsWith("tamagui") && (0, import_cli_color.colorLog)(import_cli_color.Color.Dim, `
          Config     .${import_node_path.sep}${(0, import_node_path.relative)(process.cwd(), configOutPath)}
          Components ${[
        ...componentOutPaths.map(function(p) {
          return `.${import_node_path.sep}${(0, import_node_path.relative)(process.cwd(), p)}`;
        })
      ].join(`
             `)}
          `);
    }
    var out, { unregister } = (0, import_registerRequire.registerRequire)(props.platform || "web");
    try {
      if (hasBundledOnce)
        for (var key in require.cache)
          /(core|web)[\/\\]dist/.test(key) || delete require.cache[key];
      else
        hasBundledOnce = !0;
      out = require(configOutPath);
    } catch (err) {
      throw err;
    } finally {
      unregister();
    }
    var config = out.default || out || out.config;
    if (config && config.config && !config.tokens && (config = config.config), !config)
      throw new Error(`No config: ${config}`);
    loadedConfig = config, props.outputCSS && await writeTamaguiCSS(props.outputCSS, config);
    var components = loadComponents({
      ...props,
      components: componentOutPaths
    });
    if (!components)
      throw new Error(`No components found: ${componentOutPaths.join(", ")}`);
    var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _iterator = components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var component = _step.value;
        if (component.moduleName = baseComponents[componentOutPaths.indexOf(component.moduleName)] || component.moduleName, !component.moduleName) {
          var _process_env_DEBUG3;
          (!((_process_env_DEBUG3 = process.env.DEBUG) === null || _process_env_DEBUG3 === void 0) && _process_env_DEBUG3.includes("tamagui") || process.env.IS_TAMAGUI_DEV) && console.warn(`\u26A0\uFE0F no module name found: ${component.moduleName} ${JSON.stringify(baseComponents)} in ${JSON.stringify(componentOutPaths)}`);
        }
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
    process.env.NODE_ENV === "development" && (!((_process_env_DEBUG1 = process.env.DEBUG) === null || _process_env_DEBUG1 === void 0) && _process_env_DEBUG1.startsWith("tamagui")) && console.info("Loaded components", components);
    var res = {
      components,
      nameToPaths: {},
      tamaguiConfig: config
    };
    return currentBundle = res, updateLastLoaded(res), res;
  } catch (err) {
    var _process_env_DEBUG4;
    console.error(`Error bundling tamagui config: ${err == null ? void 0 : err.message} (run with DEBUG=tamagui to see stack)`), !((_process_env_DEBUG4 = process.env.DEBUG) === null || _process_env_DEBUG4 === void 0) && _process_env_DEBUG4.includes("tamagui") && console.error(err.stack);
  } finally {
    isBundling = !1, waitForBundle.forEach(function(cb) {
      return cb();
    }), waitForBundle.clear();
  }
}
async function writeTamaguiCSS(outputCSS, config) {
  var flush = async function() {
    (0, import_cli_color.colorLog)(import_cli_color.Color.FgYellow, `    \u27A1 [tamagui] output css: ${outputCSS}`), await FS.writeFile(outputCSS, css);
  }, css = config.getCSS();
  if (typeof css != "string")
    throw new Error(`Invalid CSS: ${typeof css} ${css}`);
  try {
    (0, import_node_fs.existsSync)(outputCSS) && await (0, import_promises.readFile)(outputCSS, "utf8") === css || await flush();
  } catch (err) {
    console.info("Error writing themes", err);
  }
}
function loadComponents(props) {
  var forceExports = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, coreComponents = getCoreComponents(props), otherComponents = loadComponentsInner(props, forceExports);
  return [
    ...coreComponents,
    ...otherComponents || []
  ];
}
function getCoreComponents(props) {
  var loaded = loadComponentsInner({
    ...props,
    components: [
      "@tamagui/core"
    ]
  });
  if (!loaded)
    throw new Error("Core should always load");
  return [
    {
      ...loaded[0],
      moduleName: "@tamagui/core"
    }
  ];
}
function loadComponentsInner(props) {
  var forceExports = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, componentsModules = props.components || [], key = componentsModules.join("");
  if (!forceExports && cacheComponents[key])
    return cacheComponents[key];
  var { unregister } = (0, import_registerRequire.registerRequire)(props.platform || "web", {
    proxyWormImports: forceExports
  });
  try {
    var info = componentsModules.flatMap(function(name) {
      var extension = (0, import_node_path.extname)(name), isLocal = !!extension, isDynamic = isLocal && forceExports, fileContents = isDynamic ? (0, import_node_fs.readFileSync)(name, "utf-8") : "", loadModule = isDynamic ? (0, import_node_path.join)((0, import_node_path.dirname)(name), `.tamagui-dynamic-eval-${(0, import_node_path.basename)(name)}.tsx`) : name, writtenContents = fileContents, didBabel = !1;
      function attemptLoad() {
        var { forceExports: forceExports2 = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        isDynamic && (writtenContents = forceExports2 ? transformAddExports((0, import_babelParse.babelParse)(esbuildit(fileContents, "modern"), name)) : fileContents, FS.writeFileSync(loadModule, writtenContents), import_esbuild.default.buildSync({
          ...esbuildOptions,
          entryPoints: [
            loadModule
          ],
          outfile: loadModule,
          alias: {
            "react-native": require.resolve("@tamagui/react-native-web-lite")
          },
          bundle: !0,
          packages: "external",
          allowOverwrite: !0,
          // logLevel: 'silent',
          sourcemap: !1,
          loader: import_bundle.esbuildLoaderConfig
        })), process.env.DEBUG === "tamagui" && console.info("loadModule", loadModule, require.resolve(loadModule));
        var moduleResult = require(loadModule);
        forceExports2 || (0, import_registerRequire.setRequireResult)(name, moduleResult);
        var nameToInfo = getComponentStaticConfigByName(name, interopDefaultExport(moduleResult));
        return {
          moduleName: name,
          nameToInfo
        };
      }
      var dispose = function() {
        isDynamic && FS.removeSync(loadModule);
      };
      try {
        var res = attemptLoad({
          forceExports: !0
        });
        return didBabel = !0, res;
      } catch (err) {
        var _process_env_DEBUG;
        console.info("babel err", err, writtenContents), writtenContents = fileContents, !((_process_env_DEBUG = process.env.DEBUG) === null || _process_env_DEBUG === void 0) && _process_env_DEBUG.startsWith("tamagui") && console.info("Error parsing babel likely", err);
      } finally {
        dispose();
      }
      try {
        return attemptLoad({
          forceExports: !1
        });
      } catch (err) {
        return process.env.TAMAGUI_ENABLE_WARN_DYNAMIC_LOAD && (console.info(`

Tamagui attempted but failed to dynamically optimize components in:
  ${name}
`), console.info(err), console.info(`At: ${loadModule}`, `
didBabel: ${didBabel}`, `
In:`, writtenContents, `
isDynamic: `, isDynamic)), [];
      } finally {
        dispose();
      }
    });
    return cacheComponents[key] = info, info;
  } catch (err) {
    return console.info("Tamagui error bundling components", err.message, err.stack), null;
  } finally {
    unregister();
  }
}
var esbuildit = function(src, target) {
  return import_esbuild.default.transformSync(src, {
    ...esbuildOptions,
    ...target === "modern" && {
      target: "es2022",
      jsx: "automatic",
      loader: "tsx",
      platform: "neutral",
      format: "esm"
    }
  }).code;
};
function getComponentStaticConfigByName(name, exported) {
  var components = {};
  try {
    if (!exported || typeof exported != "object" || Array.isArray(exported))
      throw new Error(`Invalid export from package ${name}: ${typeof exported}`);
    for (var key in exported) {
      var found = getTamaguiComponent(key, exported[key]);
      if (found) {
        var { Component, ...sc } = found.staticConfig;
        components[key] = {
          staticConfig: sc
        };
      }
    }
  } catch (err) {
    process.env.TAMAGUI_ENABLE_WARN_DYNAMIC_LOAD && (console.error(`Tamagui failed getting components from ${name} (Disable error by setting environment variable TAMAGUI_ENABLE_WARN_DYNAMIC_LOAD=1)`), console.error(err));
  }
  return components;
}
function getTamaguiComponent(name, Component) {
  if (name[0].toUpperCase() === name[0]) {
    var staticConfig = Component == null ? void 0 : Component.staticConfig;
    if (staticConfig)
      return Component;
  }
}
function interopDefaultExport(mod) {
  var _mod_default;
  return (_mod_default = mod == null ? void 0 : mod.default) !== null && _mod_default !== void 0 ? _mod_default : mod;
}
var cacheComponents = {};
function transformAddExports(ast) {
  var usedNames = /* @__PURE__ */ new Set();
  return (0, import_traverse.default)(ast, {
    ExportNamedDeclaration(nodePath) {
      if (nodePath.node.specifiers) {
        var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
        try {
          for (var _iterator = nodePath.node.specifiers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
            var spec = _step.value;
            usedNames.add(t.isIdentifier(spec.exported) ? spec.exported.name : spec.exported.value);
          }
        } catch (err) {
          _didIteratorError = !0, _iteratorError = err;
        } finally {
          try {
            !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError)
              throw _iteratorError;
          }
        }
      }
    }
  }), (0, import_traverse.default)(ast, {
    VariableDeclaration(nodePath) {
      if (t.isProgram(nodePath.parent)) {
        var decs = nodePath.node.declarations;
        if (!(decs.length > 1)) {
          var [dec] = decs;
          t.isIdentifier(dec.id) && dec.init && (usedNames.has(dec.id.name) || (usedNames.add(dec.id.name), nodePath.replaceWith(t.exportNamedDeclaration(t.variableDeclaration("let", [
            dec
          ]), [
            t.exportSpecifier(t.identifier(dec.id.name), t.identifier(dec.id.name))
          ]))));
        }
      }
    }
  }), (0, import_generator.default)(ast, {
    concise: !1,
    filename: "test.tsx",
    retainLines: !1,
    sourceMaps: !1
  }).code;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  bundleConfig,
  esbuildOptions,
  getBundledConfig,
  getLoadedConfig,
  hasBundledConfigChanged,
  loadComponents,
  loadComponentsInner,
  writeTamaguiCSS
});
//# sourceMappingURL=bundleConfig.js.map
