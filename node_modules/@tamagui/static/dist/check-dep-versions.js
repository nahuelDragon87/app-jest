var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var check_dep_versions_exports = {};
__export(check_dep_versions_exports, {
  CDVC: () => CDVC
});
module.exports = __toCommonJS(check_dep_versions_exports);
var import_fast_glob = require("fast-glob"), import_js_yaml = require("js-yaml"), import_node_fs = require("node:fs"), import_node_path = require("node:path");
function calculateVersionsForEachDependency(packages, depType = DEFAULT_DEP_TYPES) {
  const dependenciesToVersionsSeen = /* @__PURE__ */ new Map();
  for (const package_ of packages)
    recordDependencyVersionsForPackageJson(dependenciesToVersionsSeen, package_, depType);
  return dependenciesToVersionsSeen;
}
function recordDependencyVersionsForPackageJson(dependenciesToVersionsSeen, package_, depType) {
  if (package_.packageJson.name && package_.packageJson.version && recordDependencyVersion(
    dependenciesToVersionsSeen,
    package_.packageJson.name,
    package_.packageJson.version,
    package_,
    !0
  ), depType.includes("dependencies" /* dependencies */) && package_.packageJson.dependencies)
    for (const [dependency, dependencyVersion] of Object.entries(
      package_.packageJson.dependencies
    ))
      dependencyVersion && recordDependencyVersion(
        dependenciesToVersionsSeen,
        dependency,
        dependencyVersion,
        package_
      );
  if (depType.includes("devDependencies" /* devDependencies */) && package_.packageJson.devDependencies)
    for (const [dependency, dependencyVersion] of Object.entries(
      package_.packageJson.devDependencies
    ))
      dependencyVersion && recordDependencyVersion(
        dependenciesToVersionsSeen,
        dependency,
        dependencyVersion,
        package_
      );
  if (depType.includes("optionalDependencies" /* optionalDependencies */) && package_.packageJson.optionalDependencies)
    for (const [dependency, dependencyVersion] of Object.entries(
      package_.packageJson.optionalDependencies
    ))
      dependencyVersion && recordDependencyVersion(
        dependenciesToVersionsSeen,
        dependency,
        dependencyVersion,
        package_
      );
  if (depType.includes("peerDependencies" /* peerDependencies */) && package_.packageJson.peerDependencies)
    for (const [dependency, dependencyVersion] of Object.entries(
      package_.packageJson.peerDependencies
    ))
      dependencyVersion && recordDependencyVersion(
        dependenciesToVersionsSeen,
        dependency,
        dependencyVersion,
        package_
      );
  if (depType.includes("resolutions" /* resolutions */) && package_.packageJson.resolutions)
    for (const [dependency, dependencyVersion] of Object.entries(
      package_.packageJson.resolutions
    ))
      dependencyVersion && recordDependencyVersion(
        dependenciesToVersionsSeen,
        dependency,
        dependencyVersion,
        package_
      );
}
function recordDependencyVersion(dependenciesToVersionsSeen, dependency, version, package_, isLocalPackageVersion = !1) {
  dependenciesToVersionsSeen.has(dependency) || dependenciesToVersionsSeen.set(dependency, []);
  const list = dependenciesToVersionsSeen.get(dependency);
  list && list.push({ package: package_, version, isLocalPackageVersion });
}
function calculateDependenciesAndVersions(dependencyVersions) {
  return [...dependencyVersions.entries()].sort((a, b) => a[0].localeCompare(b[0])).flatMap(([dependency, versionObjectsForDep]) => {
    if (!versionObjectsForDep)
      return [];
    let versions = versionObjectsForDep.filter((versionObject) => !versionObject.isLocalPackageVersion).map((versionObject) => versionObject.version);
    const localPackageVersions = versionObjectsForDep.filter((versionObject) => versionObject.isLocalPackageVersion).map((versionObject) => versionObject.version), allVersionsHaveWorkspacePrefix = versions.every(
      (version) => version.startsWith("workspace:")
    ), hasIncompatibilityWithLocalPackageVersion = versions.some(
      (version) => localPackageVersions[0] !== version
    );
    localPackageVersions.length === 1 && !allVersionsHaveWorkspacePrefix && hasIncompatibilityWithLocalPackageVersion && (versions = [...versions, ...localPackageVersions]);
    const uniqueVersions = [...new Set(versions)], uniqueVersionsWithInfo = versionsObjectsWithSortedPackages(
      uniqueVersions,
      versionObjectsForDep
    );
    return {
      dependency,
      versions: uniqueVersionsWithInfo
    };
  });
}
function versionsObjectsWithSortedPackages(versions, versionObjects) {
  return versions.map((version) => {
    const matchingVersionObjects = versionObjects.filter(
      (versionObject) => versionObject.version === version
    );
    return {
      version,
      packages: matchingVersionObjects.map((object) => object.package).sort((a, b) => Package.comparator(a, b))
    };
  });
}
const HARDCODED_IGNORED_DEPENDENCIES = /* @__PURE__ */ new Set([
  "//"
  // May be used to add comments to package.json files.
]);
function filterOutIgnoredDependencies(mismatchingVersions, ignoredDependencies, includedDependencyPatterns) {
  for (const ignoreDependency of ignoredDependencies)
    if (!mismatchingVersions.some(
      (mismatchingVersion) => mismatchingVersion.dependency === ignoreDependency
    ))
      throw new Error(
        `Specified option '--ignore-dep ${ignoreDependency}', but no version mismatches detected for this dependency.`
      );
  return ignoredDependencies.length > 0 || includedDependencyPatterns.length > 0 || mismatchingVersions.some(
    (mismatchingVersion) => HARDCODED_IGNORED_DEPENDENCIES.has(mismatchingVersion.dependency)
  ) ? mismatchingVersions.filter(
    (mismatchingVersion) => !ignoredDependencies.includes(mismatchingVersion.dependency) && includedDependencyPatterns.some(
      (ignoreDependencyPattern) => mismatchingVersion.dependency.match(ignoreDependencyPattern)
    ) && !HARDCODED_IGNORED_DEPENDENCIES.has(mismatchingVersion.dependency)
  ) : mismatchingVersions;
}
function getPackages(root, ignorePackages, ignorePackagePatterns, ignorePaths, ignorePathPatterns) {
  if (!Package.exists(root))
    throw new Error("No package.json found at provided path.");
  const packages = accumulatePackages(root, ["."]);
  for (const ignoredPackage of ignorePackages)
    if (!Package.some(packages, (package_) => package_.name === ignoredPackage))
      throw new Error(
        `Specified option '--ignore-package ${ignoredPackage}', but no such package detected in workspace.`
      );
  for (const ignoredPackagePattern of ignorePackagePatterns)
    if (
      // eslint-disable-next-line unicorn/no-array-method-this-argument,unicorn/no-array-callback-reference -- false positive
      !Package.some(packages, (package_) => ignoredPackagePattern.test(package_.name))
    )
      throw new Error(
        `Specified option '--ignore-package-pattern ${String(
          ignoredPackagePattern
        )}', but no matching packages detected in workspace.`
      );
  for (const ignoredPath of ignorePaths)
    if (
      // eslint-disable-next-line unicorn/no-array-method-this-argument,unicorn/no-array-callback-reference -- false positive
      !Package.some(packages, (package_) => package_.pathRelative.includes(ignoredPath))
    )
      throw new Error(
        `Specified option '--ignore-path ${ignoredPath}', but no matching paths detected in workspace.`
      );
  for (const ignoredPathPattern of ignorePathPatterns)
    if (
      // eslint-disable-next-line unicorn/no-array-method-this-argument,unicorn/no-array-callback-reference -- false positive
      !Package.some(
        packages,
        (package_) => ignoredPathPattern.test(package_.pathRelative)
      )
    )
      throw new Error(
        `Specified option '--ignore-path-pattern ${String(
          ignoredPathPattern
        )}', but no matching paths detected in workspace.`
      );
  return ignorePackages.length > 0 || ignorePackagePatterns.length > 0 || ignorePaths.length > 0 || ignorePathPatterns.length > 0 ? packages.filter(
    (package_) => !ignorePackages.includes(package_.name) && !ignorePackagePatterns.some(
      (ignorePackagePattern) => package_.name.match(ignorePackagePattern)
    ) && !ignorePaths.some((ignorePath) => package_.pathRelative.includes(ignorePath)) && !ignorePathPatterns.some(
      (ignorePathPattern) => package_.pathRelative.match(ignorePathPattern)
    )
  ) : packages;
}
function expandWorkspaces(root, workspacePatterns) {
  return workspacePatterns.flatMap((workspace) => workspace.includes("*") ? (0, import_fast_glob.globSync)(workspace, {
    onlyDirectories: !0,
    cwd: root,
    ignore: ["**/node_modules"]
  }) : [workspace]);
}
function accumulatePackages(root, paths) {
  const results = [];
  for (const relativePath of paths) {
    const path = (0, import_node_path.join)(root, relativePath);
    if (Package.exists(path)) {
      const package_ = new Package(path, root);
      results.push(
        // Add the current package.
        package_,
        ...accumulatePackages(path, expandWorkspaces(path, package_.workspacePatterns))
      );
    }
  }
  return results;
}
class Package {
  /** Absolute path to package */
  path;
  /** Absolute path to workspace.*/
  pathWorkspace;
  /** Absolute path to package.json. */
  pathPackageJson;
  packageJson;
  packageJsonEndsInNewline;
  pnpmWorkspacePackages;
  constructor(path, pathWorkspace) {
    this.path = path, this.pathWorkspace = pathWorkspace, this.pathPackageJson = (0, import_node_path.join)(path, "package.json");
    const packageJsonContents = (0, import_node_fs.readFileSync)(this.pathPackageJson, "utf8");
    this.packageJsonEndsInNewline = packageJsonContents.endsWith(`
`), this.packageJson = JSON.parse(packageJsonContents);
    const pnpmWorkspacePath = (0, import_node_path.join)(path, "pnpm-workspace.yaml");
    if ((0, import_node_fs.existsSync)(pnpmWorkspacePath)) {
      const pnpmWorkspaceContents = (0, import_node_fs.readFileSync)(pnpmWorkspacePath, "utf8"), pnpmWorkspaceYaml = (0, import_js_yaml.load)(pnpmWorkspaceContents);
      this.pnpmWorkspacePackages = pnpmWorkspaceYaml.packages;
    }
  }
  get name() {
    if (this.workspacePatterns.length > 0 && !this.packageJson.name)
      return "(Root)";
    if (!this.packageJson.name)
      throw new Error(`${this.pathPackageJson} missing \`name\``);
    return this.packageJson.name;
  }
  /** Relative to workspace root. */
  get pathRelative() {
    return (0, import_node_path.relative)(this.pathWorkspace, this.path);
  }
  get workspacePatterns() {
    if (this.packageJson.workspaces) {
      if (Array.isArray(this.packageJson.workspaces))
        return this.packageJson.workspaces;
      if (this.packageJson.workspaces.packages) {
        if (!Array.isArray(this.packageJson.workspaces.packages))
          throw new TypeError("package.json `workspaces.packages` is not a string array.");
        return this.packageJson.workspaces.packages;
      } else
        throw new TypeError("package.json `workspaces` is not a string array.");
    }
    if (this.pnpmWorkspacePackages) {
      if (!Array.isArray(this.pnpmWorkspacePackages))
        throw new TypeError("pnpm-workspace.yaml `packages` is not a string array.");
      return this.pnpmWorkspacePackages;
    }
    return [];
  }
  static exists(path) {
    const packageJsonPath = (0, import_node_path.join)(path, "package.json");
    return (0, import_node_fs.existsSync)(packageJsonPath);
  }
  static some(packages, callback) {
    return packages.some((package_) => callback(package_));
  }
  static comparator(package1, package2) {
    return package1.name.localeCompare(package2.name);
  }
}
var DEPENDENCY_TYPE = /* @__PURE__ */ ((DEPENDENCY_TYPE2) => (DEPENDENCY_TYPE2.dependencies = "dependencies", DEPENDENCY_TYPE2.devDependencies = "devDependencies", DEPENDENCY_TYPE2.optionalDependencies = "optionalDependencies", DEPENDENCY_TYPE2.peerDependencies = "peerDependencies", DEPENDENCY_TYPE2.resolutions = "resolutions", DEPENDENCY_TYPE2))(DEPENDENCY_TYPE || {});
const DEFAULT_DEP_TYPES = [
  "dependencies" /* dependencies */,
  "devDependencies" /* devDependencies */,
  "optionalDependencies" /* optionalDependencies */,
  "resolutions" /* resolutions */
  // peerDependencies is not included by default, see discussion in: https://github.com/bmish/check-dependency-version-consistency/issues/402
];
function check(path) {
  const options = {
    includeDepPattern: ["tamagui", "react-native-web-lite", "react-native-web-internals"]
  };
  if (options && options.depType && options.depType.some((dt) => !Object.keys(DEPENDENCY_TYPE).includes(dt)))
    throw new Error(
      `Invalid depType provided. Choices are: ${Object.keys(DEPENDENCY_TYPE).join(", ")}.`
    );
  const optionsWithDefaults = {
    fix: !1,
    ignoreDep: [],
    includeDepPattern: [],
    ignorePackage: [],
    ignorePackagePattern: [],
    ignorePath: [],
    ignorePathPattern: [],
    ...options,
    // Fallback to default if no depType(s) provided.
    depType: options && options.depType && options.depType.length > 0 ? options.depType : DEFAULT_DEP_TYPES
  }, packages = getPackages(
    path,
    optionsWithDefaults.ignorePackage,
    optionsWithDefaults.ignorePackagePattern.map((s) => new RegExp(s)),
    optionsWithDefaults.ignorePath,
    optionsWithDefaults.ignorePathPattern.map((s) => new RegExp(s))
  ), dependencies = calculateVersionsForEachDependency(
    packages,
    optionsWithDefaults.depType.map((dt) => DEPENDENCY_TYPE[dt])
    // Convert string to enum.
  ), dependenciesAndVersions = calculateDependenciesAndVersions(dependencies), dependenciesAndVersionsWithMismatches = dependenciesAndVersions.filter(
    ({ versions }) => versions.length > 1
  ), dependenciesAndVersionsWithoutIgnored = filterOutIgnoredDependencies(
    dependenciesAndVersions,
    optionsWithDefaults.ignoreDep,
    optionsWithDefaults.includeDepPattern.map((s) => new RegExp(s))
  ), dependenciesAndVersionsMismatchesWithoutIgnored = filterOutIgnoredDependencies(
    dependenciesAndVersionsWithMismatches,
    optionsWithDefaults.ignoreDep,
    optionsWithDefaults.includeDepPattern.map((s) => new RegExp(s))
  );
  return {
    // Information about all dependencies.
    dependencies: Object.fromEntries(
      dependenciesAndVersionsWithoutIgnored.map(({ dependency, versions }) => [
        dependency,
        {
          isMismatching: dependenciesAndVersionsMismatchesWithoutIgnored.some(
            (dep) => dep.dependency === dependency
          ),
          versions
        }
      ])
    )
  };
}
class CDVC {
  /** An object mapping each dependency in the workspace to information including the versions found of it. */
  dependencies;
  /**
   * @param path - path to the workspace root
   * @param options
   * @param options.fix - Whether to autofix inconsistencies (using latest version present)
   * @param options.ignoreDep - Dependency(s) to ignore mismatches for
   * @param options.includeDepPattern - RegExp(s) of dependency names to ignore mismatches for
   * @param options.ignorePackage - Workspace package(s) to ignore mismatches for
   * @param options.ignorePackagePattern - RegExp(s) of package names to ignore mismatches for
   * @param options.ignorePath - Workspace-relative path(s) of packages to ignore mismatches for
   * @param options.ignorePathPattern - RegExp(s) of workspace-relative path of packages to ignore mismatches for
   */
  constructor(path) {
    const { dependencies } = check(path);
    this.dependencies = dependencies;
  }
  toMismatchSummary() {
    return dependenciesToMismatchSummary(this.dependencies);
  }
  getDependencies() {
    return Object.keys(this.dependencies).map(
      (dependency) => this.getDependency(dependency)
    );
  }
  getDependency(name) {
    return {
      name,
      isMismatching: this.dependencies[name].isMismatching,
      versions: this.dependencies[name].versions.map((version) => ({
        version: version.version,
        packages: version.packages.map((package_) => ({
          pathRelative: package_.pathRelative
        }))
      }))
    };
  }
  get hasMismatchingDependencies() {
    return Object.values(this.dependencies).some((dep) => dep.isMismatching);
  }
}
function dependenciesToMismatchSummary(dependencies) {
  const mismatchingDependencyVersions = Object.entries(dependencies).filter(([, value]) => value.isMismatching).map(([dependency, value]) => ({ dependency, versions: value.versions }));
  if (mismatchingDependencyVersions.length === 0)
    return "";
  const tables = mismatchingDependencyVersions.map((object) => `${object.dependency} - ${object.versions.map((v) => `${v.version}`).join(", ")}`).join("");
  return [
    `Found ${mismatchingDependencyVersions.length} ${mismatchingDependencyVersions.length === 1 ? "dependency" : "dependencies"} with mismatching versions across the workspace.`,
    tables
  ].join(`
`);
}
//# sourceMappingURL=check-dep-versions.js.map
