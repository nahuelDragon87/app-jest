import Module from "node:module";
import { join } from "node:path";
var ogRequire = Module.prototype.require, didRegisterOnce = !1;
async function generateThemes(inputFile) {
  didRegisterOnce || require("esbuild-register/dist/node").register({
    hookIgnoreNodeModules: !1
  });
  var inputFilePath = inputFile[0] === "." ? join(process.cwd(), inputFile) : inputFile;
  purgeCache(inputFilePath);
  var promise = null;
  Module.prototype.require = function(id) {
    var out = ogRequire.apply(this, arguments);
    if (id === "@tamagui/theme-builder" && !promise) {
      var resolve;
      return promise = new Promise(function(res) {
        resolve = res;
      }), createThemeIntercept(out, {
        onComplete: function(result) {
          resolve?.(result.themeBuilder);
        }
      });
    }
    return out;
  };
  try {
    var requiredThemes = require(inputFilePath), themes = requiredThemes.default || requiredThemes.themes || requiredThemes[Object.keys(requiredThemes)[0]], generatedThemes = generatedThemesToTypescript(themes), tm;
    if (promise) {
      var finished = !1;
      promise.then(function() {
        finished = !0;
      }), tm = setTimeout(function() {
        finished || console.warn("Warning: ThemeBuilder didn't finish after a couple seconds, did you forget to call .build()?");
      }, 2e3);
    }
    var themeBuilder = promise ? await promise : null;
    return clearTimeout(tm), {
      generated: generatedThemes,
      state: themeBuilder?.state
    };
  } catch (err) {
    console.warn(` \u26A0\uFE0F Error running theme builder: ${err}`, err?.stack);
  } finally {
    Module.prototype.require = ogRequire;
  }
}
var dedupedTokens = /* @__PURE__ */ new Map();
function generatedThemesToTypescript(themes) {
  var dedupedThemes = /* @__PURE__ */ new Map(), dedupedThemeToNames = /* @__PURE__ */ new Map(), i = 0;
  for (var name in themes) {
    i++;
    var theme = themes[name], j = 0, _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _iterator = Object.entries(theme)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var [key, value] = _step.value;
        i++;
        var uniqueKey = `t${i}${j}`;
        dedupedTokens.has(value) || dedupedTokens.set(value, uniqueKey);
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
    var key1 = JSON.stringify(theme);
    dedupedThemes.has(key1) ? dedupedThemeToNames.set(key1, [
      ...dedupedThemeToNames.get(key1),
      name
    ]) : (dedupedThemes.set(key1, theme), dedupedThemeToNames.set(key1, [
      name
    ]));
  }
  if (!themes)
    throw new Error("Didn't find any themes exported or returned");
  var baseKeys = Object.entries(themes.light || themes[Object.keys(themes)[0]]), baseTypeString = `type Theme = {
${baseKeys.map(function(param) {
    var [k] = param;
    return `  ${k}: string;
`;
  }).join("")}
}`, out = `${baseTypeString}
`;
  out += `
function t(a: [number, number][]) {
  let res: Record<string,string> = {}
  for (const [ki, vi] of a) {
    res[ks[ki] as string] = vs[vi] as string
  }
  return res as Theme
}
`, out += `const vs = [
`;
  var index = 0, valueToIndex = {};
  dedupedTokens.forEach(function(name2, value2) {
    valueToIndex[value2] = index, index++, out += `  '${value2}',
`;
  }), out += `]

`;
  var keys = baseKeys.map(function(param) {
    var [k] = param;
    return k;
  });
  out += `const ks = [
`, out += keys.map(function(k) {
    return `'${k}'`;
  }).join(`,
`), out += `]

`;
  var nameI = 0;
  return dedupedThemes.forEach(function(theme2) {
    nameI++;
    var key2 = JSON.stringify(theme2), names = dedupedThemeToNames.get(key2), name2 = `n${nameI}`, baseTheme = `const ${name2} = ${objectToJsString(theme2, keys, valueToIndex)}`;
    out += `
${baseTheme}`;
    var duplicateThemes = names.map(function(n) {
      return `export const ${n} = ${name2}`;
    });
    out += `

` + duplicateThemes.join(`
`);
  }), out;
}
function objectToJsString(obj, keys, valueToIndex) {
  var arrItems = [];
  for (var key in obj) {
    var ki = keys.indexOf(key), vi = valueToIndex[obj[key]];
    arrItems.push(`[${ki}, ${vi}]`);
  }
  return `t([${arrItems.join(",")}])`;
}
function createThemeIntercept(createThemeExport, themeBuilderInterceptOpts) {
  return new Proxy(createThemeExport, {
    get(target, key) {
      var out = Reflect.get(target, key);
      return key === "createThemeBuilder" ? new Proxy(out, {
        apply(target2, thisArg, argArray) {
          var builder = Reflect.apply(target2, thisArg, argArray);
          return themeBuilderIntercept(builder, themeBuilderInterceptOpts);
        }
      }) : out;
    }
  });
}
function themeBuilderIntercept(themeBuilder, themeBuilderInterceptOpts) {
  return new Proxy(themeBuilder, {
    get(target, key) {
      var out = Reflect.get(target, key);
      return key === "build" && themeBuilderInterceptOpts.onComplete({
        themeBuilder
      }), out;
    }
  });
}
function purgeCache(moduleName) {
  searchCache(moduleName, function(mod) {
    delete require.cache[mod.id];
  }), Object.keys(module.constructor._pathCache).forEach(function(cacheKey) {
    cacheKey.indexOf(moduleName) > 0 && delete module.constructor._pathCache[cacheKey];
  });
}
function searchCache(moduleName, callback) {
  var mod = require.resolve(moduleName);
  mod && (mod = require.cache[mod]) !== void 0 && function traverse(mod2) {
    var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    depth > 10 || (mod2.children.forEach(function(child) {
      traverse(child, depth + 1);
    }), callback(mod2));
  }(mod);
}
export {
  generateThemes
};
//# sourceMappingURL=generate-themes.js.map
